/* automatically generated by rust-bindgen */

pub type std_string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
pub type std_istream = [u64; 35usize];
pub type std_ostream = [u64; 34usize];
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
pub type std_array__AT_Type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_mutex {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
pub type std_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_mutex>(),
        40usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex4lockEv"]
    pub fn std_mutex_lock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex8try_lockEv"]
    pub fn std_mutex_try_lock(this: *mut std_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex6unlockEv"]
    pub fn std_mutex_unlock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex13native_handleEv"]
    pub fn std_mutex_native_handle(this: *mut std_mutex) -> std_mutex_native_handle_type;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexC1Ev"]
    pub fn std_mutex_mutex(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexC1ERKS_"]
    pub fn std_mutex_mutex1(this: *mut std_mutex, arg1: *const std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexD1Ev"]
    pub fn std_mutex_mutex_destructor(this: *mut std_mutex);
}
impl std_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn native_handle(&mut self) -> std_mutex_native_handle_type {
        std_mutex_native_handle(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_mutex_mutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_mutex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_mutex_mutex1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_mutex_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unique_lock {
    pub _address: u8,
}
pub type std_unique_lock_mutex_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_mutex {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
pub type std_shared_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_shared_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_mutex>(),
        56usize,
        concat!("Size of: ", stringify!(std_shared_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_shared_mutex))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex4lockEv"]
    pub fn std_shared_mutex_lock(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex8try_lockEv"]
    pub fn std_shared_mutex_try_lock(this: *mut std_shared_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex6unlockEv"]
    pub fn std_shared_mutex_unlock(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex11lock_sharedEv"]
    pub fn std_shared_mutex_lock_shared(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex15try_lock_sharedEv"]
    pub fn std_shared_mutex_try_lock_shared(this: *mut std_shared_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex13unlock_sharedEv"]
    pub fn std_shared_mutex_unlock_shared(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex13native_handleEv"]
    pub fn std_shared_mutex_native_handle(
        this: *mut std_shared_mutex,
    ) -> std_shared_mutex_native_handle_type;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexC1Ev"]
    pub fn std_shared_mutex_shared_mutex(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexC1ERKS_"]
    pub fn std_shared_mutex_shared_mutex1(
        this: *mut std_shared_mutex,
        arg1: *const std_shared_mutex,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexD1Ev"]
    pub fn std_shared_mutex_shared_mutex_destructor(this: *mut std_shared_mutex);
}
impl std_shared_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_shared_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_shared_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_shared_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn lock_shared(&mut self) {
        std_shared_mutex_lock_shared(self)
    }
    #[inline]
    pub unsafe fn try_lock_shared(&mut self) -> bool {
        std_shared_mutex_try_lock_shared(self)
    }
    #[inline]
    pub unsafe fn unlock_shared(&mut self) {
        std_shared_mutex_unlock_shared(self)
    }
    #[inline]
    pub unsafe fn native_handle(&mut self) -> std_shared_mutex_native_handle_type {
        std_shared_mutex_native_handle(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_shared_mutex_shared_mutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_shared_mutex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_shared_mutex_shared_mutex1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_shared_mutex_shared_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_lock {
    pub _address: u8,
}
pub type std_shared_lock_mutex_type = u8;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type seal_SEAL_BYTE = u8;
///Represent an integer modulus of up to 62 bits. An instance of the SmallModulus
///class represents a non-negative integer modulus up to 62 bits. In particular,
///the encryption parameter plain_modulus, and the primes in coeff_modulus, are
///represented by instances of SmallModulus. The purpose of this class is to
///perform and store the pre-computation required by Barrett reduction.
///
///@par Thread Safety
///In general, reading from SmallModulus is thread-safe as long as no other thread
///is concurrently mutating it.
///
///@see EncryptionParameters for a description of the encryption parameters.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_global_variables_internal_mods_SmallModulus {
    pub value_: u64,
    pub const_ratio_: [u64; 3usize],
    pub bit_count_: ::std::os::raw::c_int,
    pub uint64_count_: usize,
}
#[test]
fn bindgen_test_layout_seal_util_global_variables_internal_mods_SmallModulus() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_global_variables_internal_mods_SmallModulus>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_global_variables_internal_mods_SmallModulus>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>())).value_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(value_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>()))
                .const_ratio_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(const_ratio_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>()))
                .bit_count_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(bit_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>()))
                .uint64_count_ as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(uint64_count_)
        )
    );
}
extern "C" {
    ///Returns the significant bit count of the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus9bit_countEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_bit_count(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns the size (in 64-bit words) of the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus12uint64_countEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_uint64_count(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> usize;
}
extern "C" {
    ///Returns a const pointer to the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus4dataEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_data(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> *const u64;
}
extern "C" {
    ///Returns the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus5valueEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_value(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    ///Returns the Barrett ratio computed for the value of the current SmallModulus.
    ///The first two components of the Barrett ratio are the floor of 2^128/value,
    ///and the third component is the remainder.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus11const_ratioEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_const_ratio(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns whether the value of the current SmallModulus is zero.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus7is_zeroEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_is_zero(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool;
}
extern "C" {
    ///Saves the SmallModulus to an output stream. The full state of the modulus is
    ///serialized. The output is in binary format and not human-readable. The output
    ///stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the SmallModulus to
    ///@throws std::exception if the SmallModulus could not be written to stream
    #[link_name = "\u{1}_ZNK4seal12SmallModulus4saveERSo"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_save(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        stream: *mut std_ostream,
    );
}
extern "C" {
    ///Loads a SmallModulus from an input stream overwriting the current SmallModulus.
    ///
    ///@param[in] stream The stream to load the SmallModulus from
    ///@throws std::exception if a valid SmallModulus could not be read from stream
    #[link_name = "\u{1}_ZN4seal12SmallModulus4loadERSi"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_load(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Creates a SmallModulus instance. The value of the SmallModulus is set to
    ///the given value, or to zero by default.
    ///
    ///@param[in] value The integer modulus
    ///@throws std::invalid_argument if value is 1 or more than 62 bits
    #[link_name = "\u{1}_ZN4seal12SmallModulusC1Em"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_SmallModulus(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        value: u64,
    );
}
extern "C" {
    ///Creates a new SmallModulus by copying a given one.
    ///
    ///@param[in] copy The SmallModulus to copy from
    #[link_name = "\u{1}_ZN4seal12SmallModulusC1ERKS0_"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_SmallModulus1(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        copy: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    ///Creates a new SmallModulus by copying a given one.
    ///
    ///@param[in] source The SmallModulus to move from
    #[link_name = "\u{1}_ZN4seal12SmallModulusC1EOS0_"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_SmallModulus2(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        source: *mut seal_util_global_variables_internal_mods_SmallModulus,
    );
}
impl seal_util_global_variables_internal_mods_SmallModulus {
    #[inline]
    pub unsafe fn bit_count(&self) -> ::std::os::raw::c_int {
        seal_util_global_variables_internal_mods_SmallModulus_bit_count(self)
    }
    #[inline]
    pub unsafe fn uint64_count(&self) -> usize {
        seal_util_global_variables_internal_mods_SmallModulus_uint64_count(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const u64 {
        seal_util_global_variables_internal_mods_SmallModulus_data(self)
    }
    #[inline]
    pub unsafe fn value(&self) -> u64 {
        seal_util_global_variables_internal_mods_SmallModulus_value(self)
    }
    #[inline]
    pub unsafe fn const_ratio(&self) -> *mut [u64; 3usize] {
        seal_util_global_variables_internal_mods_SmallModulus_const_ratio(self)
    }
    #[inline]
    pub unsafe fn is_zero(&self) -> bool {
        seal_util_global_variables_internal_mods_SmallModulus_is_zero(self)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_util_global_variables_internal_mods_SmallModulus_save(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, stream: *mut std_istream) {
        seal_util_global_variables_internal_mods_SmallModulus_load(self, stream)
    }
    #[inline]
    pub unsafe fn new(value: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_global_variables_internal_mods_SmallModulus_SmallModulus(
            &mut __bindgen_tmp,
            value,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_global_variables_internal_mods_SmallModulus) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_global_variables_internal_mods_SmallModulus_SmallModulus1(
            &mut __bindgen_tmp,
            copy,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_util_global_variables_internal_mods_SmallModulus) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_global_variables_internal_mods_SmallModulus_SmallModulus2(
            &mut __bindgen_tmp,
            source,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_is_uint64 {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12reverse_bitsEj"]
    pub fn seal_util_reverse_bits(operand: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12reverse_bitsEji"]
    pub fn seal_util_reverse_bits1(operand: u32, bit_count: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21get_msb_index_genericEPmm"]
    pub fn seal_util_get_msb_index_generic(result: *mut ::std::os::raw::c_ulong, value: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25get_significant_bit_countEm"]
    pub fn seal_util_get_significant_bit_count(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util11is_hex_charEc"]
    pub fn seal_util_is_hex_char(hex: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19nibble_to_upper_hexEi"]
    pub fn seal_util_nibble_to_upper_hex(nibble: ::std::os::raw::c_int) -> ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13hex_to_nibbleEc"]
    pub fn seal_util_hex_to_nibble(hex: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15get_uint64_byteEPmm"]
    pub fn seal_util_get_uint64_byte(value: *mut u64, byte_index: usize) -> *mut seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15get_uint64_byteEPKmm"]
    pub fn seal_util_get_uint64_byte1(
        value: *const u64,
        byte_index: usize,
    ) -> *const seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24get_hex_string_bit_countEPKci"]
    pub fn seal_util_get_hex_string_bit_count(
        hex_string: *const ::std::os::raw::c_char,
        char_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type seal_util_ReaderLock = [u64; 2usize];
pub type seal_util_WriterLock = [u64; 2usize];
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_util_ReaderWriterLocker {
    pub rw_lock_mutex_: std_shared_mutex,
}
#[test]
fn bindgen_test_layout_seal_util_ReaderWriterLocker() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ReaderWriterLocker>(),
        56usize,
        concat!("Size of: ", stringify!(seal_util_ReaderWriterLocker))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ReaderWriterLocker>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_ReaderWriterLocker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_ReaderWriterLocker>())).rw_lock_mutex_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_ReaderWriterLocker),
            "::",
            stringify!(rw_lock_mutex_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker12acquire_readEv"]
    pub fn seal_util_ReaderWriterLocker_acquire_read(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_ReaderLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker13acquire_writeEv"]
    pub fn seal_util_ReaderWriterLocker_acquire_write(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_WriterLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker16try_acquire_readEv"]
    pub fn seal_util_ReaderWriterLocker_try_acquire_read(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_ReaderLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker17try_acquire_writeEv"]
    pub fn seal_util_ReaderWriterLocker_try_acquire_write(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_WriterLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLockerC1Ev"]
    pub fn seal_util_ReaderWriterLocker_ReaderWriterLocker(this: *mut seal_util_ReaderWriterLocker);
}
impl seal_util_ReaderWriterLocker {
    #[inline]
    pub unsafe fn acquire_read(&mut self) -> seal_util_ReaderLock {
        seal_util_ReaderWriterLocker_acquire_read(self)
    }
    #[inline]
    pub unsafe fn acquire_write(&mut self) -> seal_util_WriterLock {
        seal_util_ReaderWriterLocker_acquire_write(self)
    }
    #[inline]
    pub unsafe fn try_acquire_read(&mut self) -> seal_util_ReaderLock {
        seal_util_ReaderWriterLocker_try_acquire_read(self)
    }
    #[inline]
    pub unsafe fn try_acquire_write(&mut self) -> seal_util_WriterLock {
        seal_util_ReaderWriterLocker_try_acquire_write(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_ReaderWriterLocker_ReaderWriterLocker(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_util_MemoryPoolItem {
    pub data_: *mut seal_SEAL_BYTE,
    pub next_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolItem() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolItem>(),
        16usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolItem))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolItem>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolItem>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolItem),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolItem>())).next_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolItem),
            "::",
            stringify!(next_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItem4dataEv"]
    pub fn seal_util_MemoryPoolItem_data(
        this: *mut seal_util_MemoryPoolItem,
    ) -> *mut seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14MemoryPoolItem4dataEv"]
    pub fn seal_util_MemoryPoolItem_data1(
        this: *const seal_util_MemoryPoolItem,
    ) -> *const seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItem4nextEv"]
    pub fn seal_util_MemoryPoolItem_next(
        this: *mut seal_util_MemoryPoolItem,
    ) -> *mut *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14MemoryPoolItem4nextEv"]
    pub fn seal_util_MemoryPoolItem_next1(
        this: *const seal_util_MemoryPoolItem,
    ) -> *const seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItemC1EPNS_9SEAL_BYTEE"]
    pub fn seal_util_MemoryPoolItem_MemoryPoolItem(
        this: *mut seal_util_MemoryPoolItem,
        data: *mut seal_SEAL_BYTE,
    );
}
impl Default for seal_util_MemoryPoolItem {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolItem {
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_SEAL_BYTE {
        seal_util_MemoryPoolItem_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *const seal_SEAL_BYTE {
        seal_util_MemoryPoolItem_data1(self)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> *mut *mut seal_util_MemoryPoolItem {
        seal_util_MemoryPoolItem_next(self)
    }
    #[inline]
    pub unsafe fn next1(&self) -> *const seal_util_MemoryPoolItem {
        seal_util_MemoryPoolItem_next1(self)
    }
    #[inline]
    pub unsafe fn new(data: *mut seal_SEAL_BYTE) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolItem_MemoryPoolItem(&mut __bindgen_tmp, data);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct seal_util_MemoryPoolHead__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHead {
    pub vtable_: *const seal_util_MemoryPoolHead__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_util_MemoryPoolHead_allocation {
    pub size: usize,
    pub data_ptr: *mut seal_SEAL_BYTE,
    pub free: usize,
    pub head_ptr: *mut seal_SEAL_BYTE,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHead_allocation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHead_allocation>(),
        32usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHead_allocation))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHead_allocation>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_util_MemoryPoolHead_allocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).data_ptr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(data_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).free as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).head_ptr as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(head_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolHead10allocationC1Ev"]
    pub fn seal_util_MemoryPoolHead_allocation_allocation(
        this: *mut seal_util_MemoryPoolHead_allocation,
    );
}
impl Default for seal_util_MemoryPoolHead_allocation {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHead_allocation {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHead_allocation_allocation(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHead() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHead>(),
        8usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHead))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHead>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHead))
    );
}
impl Default for seal_util_MemoryPoolHead {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolHeadD1Ev"]
    pub fn seal_util_MemoryPoolHead_MemoryPoolHead_destructor(this: *mut seal_util_MemoryPoolHead);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHeadMT {
    pub _base: seal_util_MemoryPoolHead,
    pub clear_on_destruction_: bool,
    pub locked_: u8,
    pub item_byte_count_: usize,
    pub item_count_: usize,
    pub allocs_: [u64; 3usize],
    pub first_item_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHeadMT() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHeadMT>(),
        64usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHeadMT))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHeadMT>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHeadMT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).locked_ as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(locked_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).item_byte_count_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(item_byte_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).item_count_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(item_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).allocs_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(allocs_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).first_item_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(first_item_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMTC1Emb"]
    pub fn seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT(
        this: *mut seal_util_MemoryPoolHeadMT,
        item_byte_count: usize,
        clear_on_destruction: bool,
    );
}
impl Default for seal_util_MemoryPoolHeadMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHeadMT {
    #[inline]
    pub unsafe fn new(item_byte_count: usize, clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT(
            &mut __bindgen_tmp,
            item_byte_count,
            clear_on_destruction,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMTD1Ev"]
    pub fn seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT_destructor(
        this: *mut seal_util_MemoryPoolHeadMT,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadMT15item_byte_countEv"]
    pub fn seal_util_MemoryPoolHeadMT_item_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadMT10item_countEv"]
    pub fn seal_util_MemoryPoolHeadMT_item_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMT3getEv"]
    pub fn seal_util_MemoryPoolHeadMT_get(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMT3addEPNS0_14MemoryPoolItemE"]
    pub fn seal_util_MemoryPoolHeadMT_add(
        this: *mut ::std::os::raw::c_void,
        new_first: *mut seal_util_MemoryPoolItem,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHeadST {
    pub _base: seal_util_MemoryPoolHead,
    pub clear_on_destruction_: bool,
    pub item_byte_count_: usize,
    pub item_count_: usize,
    pub allocs_: [u64; 3usize],
    pub first_item_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHeadST() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHeadST>(),
        64usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHeadST))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHeadST>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHeadST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).item_byte_count_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(item_byte_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).item_count_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(item_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).allocs_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(allocs_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).first_item_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(first_item_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadSTC1Emb"]
    pub fn seal_util_MemoryPoolHeadST_MemoryPoolHeadST(
        this: *mut seal_util_MemoryPoolHeadST,
        item_byte_count: usize,
        clear_on_destruction: bool,
    );
}
impl Default for seal_util_MemoryPoolHeadST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHeadST {
    #[inline]
    pub unsafe fn new(item_byte_count: usize, clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHeadST_MemoryPoolHeadST(
            &mut __bindgen_tmp,
            item_byte_count,
            clear_on_destruction,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadSTD1Ev"]
    pub fn seal_util_MemoryPoolHeadST_MemoryPoolHeadST_destructor(
        this: *mut seal_util_MemoryPoolHeadST,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadST15item_byte_countEv"]
    pub fn seal_util_MemoryPoolHeadST_item_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadST10item_countEv"]
    pub fn seal_util_MemoryPoolHeadST_item_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadST3getEv"]
    pub fn seal_util_MemoryPoolHeadST_get(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadST3addEPNS0_14MemoryPoolItemE"]
    pub fn seal_util_MemoryPoolHeadST_add(
        this: *mut ::std::os::raw::c_void,
        new_first: *mut seal_util_MemoryPoolItem,
    );
}
#[repr(C)]
pub struct seal_util_MemoryPool__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPool {
    pub vtable_: *const seal_util_MemoryPool__bindgen_vtable,
}
pub const seal_util_MemoryPool_alloc_size_multiplier: f64 = 1.05;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool27max_single_alloc_byte_countE"]
    pub static mut seal_util_MemoryPool_max_single_alloc_byte_count: usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool19max_pool_head_countE"]
    pub static mut seal_util_MemoryPool_max_pool_head_count: usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool26max_batch_alloc_byte_countE"]
    pub static mut seal_util_MemoryPool_max_batch_alloc_byte_count: usize;
}
pub const seal_util_MemoryPool_first_alloc_count: usize = 1;
#[test]
fn bindgen_test_layout_seal_util_MemoryPool() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPool>(),
        8usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPool))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPool>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPool))
    );
}
impl Default for seal_util_MemoryPool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPoolD1Ev"]
    pub fn seal_util_MemoryPool_MemoryPool_destructor(this: *mut seal_util_MemoryPool);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolMT {
    pub _base: seal_util_MemoryPool,
    pub clear_on_destruction_: bool,
    pub pools_locker_: seal_util_ReaderWriterLocker,
    pub pools_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolMT() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolMT>(),
        96usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolMT))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolMT>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolMT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).pools_locker_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(pools_locker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).pools_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(pools_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTC1Eb"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT(
        this: *mut seal_util_MemoryPoolMT,
        clear_on_destruction: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTC1ERKS1_"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT1(
        this: *mut seal_util_MemoryPoolMT,
        copy: *const seal_util_MemoryPoolMT,
    );
}
impl Default for seal_util_MemoryPoolMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolMT {
    #[inline]
    pub unsafe fn new(clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolMT_MemoryPoolMT(&mut __bindgen_tmp, clear_on_destruction);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_MemoryPoolMT) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolMT_MemoryPoolMT1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTD1Ev"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT_destructor(this: *mut seal_util_MemoryPoolMT);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMT18get_for_byte_countEm"]
    pub fn seal_util_MemoryPoolMT_get_for_byte_count(
        this: *mut ::std::os::raw::c_void,
        byte_count: usize,
    ) -> seal_util_Pointer<seal_SEAL_BYTE>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolMT10pool_countEv"]
    pub fn seal_util_MemoryPoolMT_pool_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolMT16alloc_byte_countEv"]
    pub fn seal_util_MemoryPoolMT_alloc_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolST {
    pub _base: seal_util_MemoryPool,
    pub clear_on_destruction_: bool,
    pub pools_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolST() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolST>(),
        40usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolST))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolST>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolST>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolST),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolST>())).pools_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolST),
            "::",
            stringify!(pools_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTC1Eb"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST(
        this: *mut seal_util_MemoryPoolST,
        clear_on_destruction: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTC1ERKS1_"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST1(
        this: *mut seal_util_MemoryPoolST,
        copy: *const seal_util_MemoryPoolST,
    );
}
impl Default for seal_util_MemoryPoolST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolST {
    #[inline]
    pub unsafe fn new(clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolST_MemoryPoolST(&mut __bindgen_tmp, clear_on_destruction);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_MemoryPoolST) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolST_MemoryPoolST1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTD1Ev"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST_destructor(this: *mut seal_util_MemoryPoolST);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolST18get_for_byte_countEm"]
    pub fn seal_util_MemoryPoolST_get_for_byte_count(
        this: *mut ::std::os::raw::c_void,
        byte_count: usize,
    ) -> seal_util_Pointer<seal_SEAL_BYTE>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolST10pool_countEv"]
    pub fn seal_util_MemoryPoolST_pool_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolST16alloc_byte_countEv"]
    pub fn seal_util_MemoryPoolST_alloc_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_Pointer<T> {
    pub data_: *mut T,
    pub head_: *mut seal_util_MemoryPoolHead,
    pub item_: *mut seal_util_MemoryPoolItem,
    pub alias_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for seal_util_Pointer<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_seal_SEAL_BYTE_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_ConstPointer<T> {
    pub data_: *mut T,
    pub head_: *mut seal_util_MemoryPoolHead,
    pub item_: *mut seal_util_MemoryPoolItem,
    pub alias_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for seal_util_ConstPointer<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18uint_to_hex_stringB5cxx11EPKmm"]
    pub fn seal_util_uint_to_hex_string(value: *const u64, uint64_count: usize) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18uint_to_dec_stringB5cxx11EPKmmRNS0_10MemoryPoolE"]
    pub fn seal_util_uint_to_dec_string(
        value: *const u64,
        uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18hex_string_to_uintEPKcimPm"]
    pub fn seal_util_hex_string_to_uint(
        hex_string: *const ::std::os::raw::c_char,
        char_count: ::std::os::raw::c_int,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13allocate_uintEmRNS0_10MemoryPoolE"]
    pub fn seal_util_allocate_uint(
        uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_zero_uintEmPm"]
    pub fn seal_util_set_zero_uint(uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18allocate_zero_uintEmRNS0_10MemoryPoolE"]
    pub fn seal_util_allocate_zero_uint(
        uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util8set_uintEmmPm"]
    pub fn seal_util_set_uint(value: u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_uint_uintEPKmmPm"]
    pub fn seal_util_set_uint_uint(value: *const u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12is_zero_uintEPKmm"]
    pub fn seal_util_is_zero_uint(value: *const u64, uint64_count: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13is_equal_uintEPKmmm"]
    pub fn seal_util_is_equal_uint(value: *const u64, uint64_count: usize, scalar: u64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20is_high_bit_set_uintEPKmm"]
    pub fn seal_util_is_high_bit_set_uint(value: *const u64, uint64_count: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15is_bit_set_uintEPKmmi"]
    pub fn seal_util_is_bit_set_uint(
        value: *const u64,
        uint64_count: usize,
        bit_index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12set_bit_uintEPmmi"]
    pub fn seal_util_set_bit_uint(
        value: *mut u64,
        uint64_count: usize,
        bit_index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util30get_significant_bit_count_uintEPKmm"]
    pub fn seal_util_get_significant_bit_count_uint(
        value: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util33get_significant_uint64_count_uintEPKmm"]
    pub fn seal_util_get_significant_uint64_count_uint(
        value: *const u64,
        uint64_count: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_uint_uintEPKmmmPm"]
    pub fn seal_util_set_uint_uint1(
        value: *const u64,
        value_uint64_count: usize,
        result_uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16get_power_of_twoEm"]
    pub fn seal_util_get_power_of_two(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util26get_power_of_two_minus_oneEm"]
    pub fn seal_util_get_power_of_two_minus_one(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21get_power_of_two_uintEPKmm"]
    pub fn seal_util_get_power_of_two_uint(
        operand: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31get_power_of_two_minus_one_uintEPKmm"]
    pub fn seal_util_get_power_of_two_minus_one_uint(
        operand: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20filter_highbits_uintEPmmi"]
    pub fn seal_util_filter_highbits_uint(
        operand: *mut u64,
        uint64_count: usize,
        bit_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24duplicate_uint_if_neededEPKmmmbRNS0_10MemoryPoolE"]
    pub fn seal_util_duplicate_uint_if_needed(
        input: *const u64,
        uint64_count: usize,
        new_uint64_count: usize,
        force: bool,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_ConstPointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17compare_uint_uintEPKmS2_m"]
    pub fn seal_util_compare_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17compare_uint_uintEPKmmS2_m"]
    pub fn seal_util_compare_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25is_greater_than_uint_uintEPKmS2_m"]
    pub fn seal_util_is_greater_than_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util34is_greater_than_or_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_greater_than_or_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_less_than_uint_uintEPKmS2_m"]
    pub fn seal_util_is_less_than_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31is_less_than_or_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_less_than_or_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18is_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_not_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_not_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25is_greater_than_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_greater_than_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util34is_greater_than_or_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_greater_than_or_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_less_than_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_less_than_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31is_less_than_or_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_less_than_or_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18is_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_not_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_not_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14hamming_weightEm"]
    pub fn seal_util_hamming_weight(value: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20hamming_weight_splitEm"]
    pub fn seal_util_hamming_weight_split(value: u64) -> u64;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_HashFunction {
    pub _address: u8,
}
pub type seal_util_HashFunction_sha3_block_type = [u64; 4usize];
pub type seal_util_HashFunction_sha3_state_type = [[u64; 5usize]; 5usize];
pub const seal_util_HashFunction_sha3_block_uint64_count: usize = 4;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction15sha3_zero_blockE"]
    pub static mut seal_util_HashFunction_sha3_zero_block: seal_util_HashFunction_sha3_block_type;
}
pub const seal_util_HashFunction_sha3_round_count: u8 = 24;
pub const seal_util_HashFunction_sha3_rate_uint64_count: u8 = 17;
pub const seal_util_HashFunction_sha3_capacity_uint64_count: u8 = 8;
pub const seal_util_HashFunction_sha3_state_uint64_count: u8 = 25;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction8sha3_rhoE"]
    pub static mut seal_util_HashFunction_sha3_rho: [u8; 24usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction17sha3_round_constsE"]
    pub static mut seal_util_HashFunction_sha3_round_consts: [u64; 24usize];
}
#[test]
fn bindgen_test_layout_seal_util_HashFunction() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_HashFunction>(),
        1usize,
        concat!("Size of: ", stringify!(seal_util_HashFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_HashFunction>(),
        1usize,
        concat!("Alignment of ", stringify!(seal_util_HashFunction))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction9sha3_hashEPKmmRSt5arrayImLm4EE"]
    pub fn seal_util_HashFunction_sha3_hash(
        input: *const u64,
        uint64_count: usize,
        destination: *mut seal_util_HashFunction_sha3_block_type,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction9sha3_hashEmRSt5arrayImLm4EE"]
    pub fn seal_util_HashFunction_sha3_hash1(
        input: u64,
        destination: *mut seal_util_HashFunction_sha3_block_type,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunctionC1Ev"]
    pub fn seal_util_HashFunction_HashFunction(this: *mut seal_util_HashFunction);
}
impl seal_util_HashFunction {
    #[inline]
    pub unsafe fn sha3_hash(
        input: *const u64,
        uint64_count: usize,
        destination: *mut seal_util_HashFunction_sha3_block_type,
    ) {
        seal_util_HashFunction_sha3_hash(input, uint64_count, destination)
    }
    #[inline]
    pub unsafe fn sha3_hash1(input: u64, destination: *mut seal_util_HashFunction_sha3_block_type) {
        seal_util_HashFunction_sha3_hash1(input, destination)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_HashFunction_HashFunction(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_SmallNTTTables {
    pub pool_: seal_MemoryPoolHandle,
    pub generated_: bool,
    pub root_: u64,
    pub root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub scaled_root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub inv_root_powers_div_two_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub scaled_inv_root_powers_div_two_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub coeff_count_power_: ::std::os::raw::c_int,
    pub coeff_count_: usize,
    pub modulus_: seal_util_global_variables_internal_mods_SmallModulus,
    pub inv_root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub scaled_inv_root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub inv_degree_modulo_: u64,
}
#[test]
fn bindgen_test_layout_seal_util_SmallNTTTables() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_SmallNTTTables>(),
        296usize,
        concat!("Size of: ", stringify!(seal_util_SmallNTTTables))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_SmallNTTTables>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_SmallNTTTables))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).generated_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(generated_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).root_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(root_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).root_powers_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).scaled_root_powers_ as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(scaled_root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).inv_root_powers_div_two_
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(inv_root_powers_div_two_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).scaled_inv_root_powers_div_two_
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(scaled_inv_root_powers_div_two_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).coeff_count_power_ as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(coeff_count_power_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).coeff_count_ as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).modulus_ as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).inv_root_powers_ as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(inv_root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).scaled_inv_root_powers_ as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(scaled_inv_root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).inv_degree_modulo_ as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(inv_degree_modulo_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables12is_generatedEv"]
    pub fn seal_util_SmallNTTTables_is_generated(this: *const seal_util_SmallNTTTables) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTables8generateEiRKNS_12SmallModulusE"]
    pub fn seal_util_SmallNTTTables_generate(
        this: *mut seal_util_SmallNTTTables,
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTables5resetEv"]
    pub fn seal_util_SmallNTTTables_reset(this: *mut seal_util_SmallNTTTables);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables8get_rootEv"]
    pub fn seal_util_SmallNTTTables_get_root(this: *const seal_util_SmallNTTTables) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables20get_from_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables27get_from_scaled_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_scaled_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables24get_from_inv_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_inv_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables31get_from_scaled_inv_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_scaled_inv_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables32get_from_inv_root_powers_div_twoEm"]
    pub fn seal_util_SmallNTTTables_get_from_inv_root_powers_div_two(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables39get_from_scaled_inv_root_powers_div_twoEm"]
    pub fn seal_util_SmallNTTTables_get_from_scaled_inv_root_powers_div_two(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables21get_inv_degree_moduloEv"]
    pub fn seal_util_SmallNTTTables_get_inv_degree_modulo(
        this: *const seal_util_SmallNTTTables,
    ) -> *const u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables7modulusEv"]
    pub fn seal_util_SmallNTTTables_modulus(
        this: *const seal_util_SmallNTTTables,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables17coeff_count_powerEv"]
    pub fn seal_util_SmallNTTTables_coeff_count_power(
        this: *const seal_util_SmallNTTTables,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables11coeff_countEv"]
    pub fn seal_util_SmallNTTTables_coeff_count(this: *const seal_util_SmallNTTTables) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTablesC1ENS_16MemoryPoolHandleE"]
    pub fn seal_util_SmallNTTTables_SmallNTTTables(
        this: *mut seal_util_SmallNTTTables,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTablesC1EiRKNS_12SmallModulusENS_16MemoryPoolHandleE"]
    pub fn seal_util_SmallNTTTables_SmallNTTTables1(
        this: *mut seal_util_SmallNTTTables,
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: seal_MemoryPoolHandle,
    );
}
impl Default for seal_util_SmallNTTTables {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_SmallNTTTables {
    #[inline]
    pub unsafe fn is_generated(&self) -> bool {
        seal_util_SmallNTTTables_is_generated(self)
    }
    #[inline]
    pub unsafe fn generate(
        &mut self,
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool {
        seal_util_SmallNTTTables_generate(self, coeff_count_power, modulus)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        seal_util_SmallNTTTables_reset(self)
    }
    #[inline]
    pub unsafe fn get_root(&self) -> u64 {
        seal_util_SmallNTTTables_get_root(self)
    }
    #[inline]
    pub unsafe fn get_from_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_scaled_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_scaled_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_inv_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_inv_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_scaled_inv_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_scaled_inv_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_inv_root_powers_div_two(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_inv_root_powers_div_two(self, index)
    }
    #[inline]
    pub unsafe fn get_from_scaled_inv_root_powers_div_two(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_scaled_inv_root_powers_div_two(self, index)
    }
    #[inline]
    pub unsafe fn get_inv_degree_modulo(&self) -> *const u64 {
        seal_util_SmallNTTTables_get_inv_degree_modulo(self)
    }
    #[inline]
    pub unsafe fn modulus(&self) -> *const seal_util_global_variables_internal_mods_SmallModulus {
        seal_util_SmallNTTTables_modulus(self)
    }
    #[inline]
    pub unsafe fn coeff_count_power(&self) -> ::std::os::raw::c_int {
        seal_util_SmallNTTTables_coeff_count_power(self)
    }
    #[inline]
    pub unsafe fn coeff_count(&self) -> usize {
        seal_util_SmallNTTTables_coeff_count(self)
    }
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_SmallNTTTables_SmallNTTTables(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: seal_MemoryPoolHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_SmallNTTTables_SmallNTTTables1(
            &mut __bindgen_tmp,
            coeff_count_power,
            modulus,
            pool,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util26ntt_negacyclic_harvey_lazyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_ntt_negacyclic_harvey_lazy(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21ntt_negacyclic_harveyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_ntt_negacyclic_harvey(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util34inverse_ntt_negacyclic_harvey_lazyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_inverse_ntt_negacyclic_harvey_lazy(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util29inverse_ntt_negacyclic_harveyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_inverse_ntt_negacyclic_harvey(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_seal_SEAL_BYTE_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union seal_aes_block {
    pub u32: [u32; 4usize],
    pub u64: [u64; 2usize],
    pub i128: __m128i,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_seal_aes_block() {
    assert_eq!(
        ::std::mem::size_of::<seal_aes_block>(),
        16usize,
        concat!("Size of: ", stringify!(seal_aes_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).i128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(i128)
        )
    );
}
impl Default for seal_aes_block {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_AESEncryptor {
    pub round_key_: [__m128i; 11usize],
}
#[test]
fn bindgen_test_layout_seal_AESEncryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_AESEncryptor>(),
        176usize,
        concat!("Size of: ", stringify!(seal_AESEncryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_AESEncryptor>())).round_key_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_AESEncryptor),
            "::",
            stringify!(round_key_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptor7set_keyERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_set_key(this: *mut seal_AESEncryptor, key: *const seal_aes_block);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptERKNS_9aes_blockERS1_"]
    pub fn seal_AESEncryptor_ecb_encrypt(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_ecb_encrypt1(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
    ) -> seal_aes_block;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptEPKNS_9aes_blockEmPS1_"]
    pub fn seal_AESEncryptor_ecb_encrypt2(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor15counter_encryptEmmPNS_9aes_blockE"]
    pub fn seal_AESEncryptor_counter_encrypt(
        this: *const seal_AESEncryptor,
        start_index: usize,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1Ev"]
    pub fn seal_AESEncryptor_AESEncryptor(this: *mut seal_AESEncryptor);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1ERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_AESEncryptor1(
        this: *mut seal_AESEncryptor,
        key: *const seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1Emm"]
    pub fn seal_AESEncryptor_AESEncryptor2(this: *mut seal_AESEncryptor, key_lw: u64, key_hw: u64);
}
impl seal_AESEncryptor {
    #[inline]
    pub unsafe fn set_key(&mut self, key: *const seal_aes_block) {
        seal_AESEncryptor_set_key(self, key)
    }
    #[inline]
    pub unsafe fn ecb_encrypt(
        &self,
        plaintext: *const seal_aes_block,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_ecb_encrypt(self, plaintext, ciphertext)
    }
    #[inline]
    pub unsafe fn ecb_encrypt1(&self, plaintext: *const seal_aes_block) -> seal_aes_block {
        seal_AESEncryptor_ecb_encrypt1(self, plaintext)
    }
    #[inline]
    pub unsafe fn ecb_encrypt2(
        &self,
        plaintext: *const seal_aes_block,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_ecb_encrypt2(self, plaintext, aes_block_count, ciphertext)
    }
    #[inline]
    pub unsafe fn counter_encrypt(
        &self,
        start_index: usize,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_counter_encrypt(self, start_index, aes_block_count, ciphertext)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(key: *const seal_aes_block) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor1(&mut __bindgen_tmp, key);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(key_lw: u64, key_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor2(&mut __bindgen_tmp, key_lw, key_hw);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_AESDecryptor {
    pub round_key_: [__m128i; 11usize],
}
#[test]
fn bindgen_test_layout_seal_AESDecryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_AESDecryptor>(),
        176usize,
        concat!("Size of: ", stringify!(seal_AESDecryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_AESDecryptor>())).round_key_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_AESDecryptor),
            "::",
            stringify!(round_key_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor7set_keyERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_set_key(this: *mut seal_AESDecryptor, key: *const seal_aes_block);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor11ecb_decryptERKNS_9aes_blockERS1_"]
    pub fn seal_AESDecryptor_ecb_decrypt(
        this: *mut seal_AESDecryptor,
        ciphertext: *const seal_aes_block,
        plaintext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor11ecb_decryptERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_ecb_decrypt1(
        this: *mut seal_AESDecryptor,
        ciphertext: *const seal_aes_block,
    ) -> seal_aes_block;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptorC1Ev"]
    pub fn seal_AESDecryptor_AESDecryptor(this: *mut seal_AESDecryptor);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptorC1ERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_AESDecryptor1(
        this: *mut seal_AESDecryptor,
        key: *const seal_aes_block,
    );
}
impl seal_AESDecryptor {
    #[inline]
    pub unsafe fn set_key(&mut self, key: *const seal_aes_block) {
        seal_AESDecryptor_set_key(self, key)
    }
    #[inline]
    pub unsafe fn ecb_decrypt(
        &mut self,
        ciphertext: *const seal_aes_block,
        plaintext: *mut seal_aes_block,
    ) {
        seal_AESDecryptor_ecb_decrypt(self, ciphertext, plaintext)
    }
    #[inline]
    pub unsafe fn ecb_decrypt1(&mut self, ciphertext: *const seal_aes_block) -> seal_aes_block {
        seal_AESDecryptor_ecb_decrypt1(self, ciphertext)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESDecryptor_AESDecryptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(key: *const seal_aes_block) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESDecryptor_AESDecryptor1(&mut __bindgen_tmp, key);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct seal_UniformRandomGenerator__bindgen_vtable(::std::os::raw::c_void);
///Provides the base-class for a uniform random number generator. Instances of
///this class are typically returned from the UniformRandomGeneratorFactory class.
///This class is meant for users to sub-class to implement their own random number
///generators. The implementation should provide a uniform random unsigned 32-bit
///value for each call to generate(). Note that the library will never make
///concurrent calls to generate() to the same instance (but individual instances
///of the same class may have concurrent calls). The uniformity and unpredictability
///of the numbers generated is essential for making a secure cryptographic system.
///
///@see UniformRandomGeneratorFactory for the base-class of a factory class that
///generates UniformRandomGenerator instances.
///@see StandardRandomAdapter for an implementation of UniformRandomGenerator to
///support the C++ standard library's random number generators.
#[repr(C)]
#[derive(Debug)]
pub struct seal_UniformRandomGenerator {
    pub vtable_: *const seal_UniformRandomGenerator__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_UniformRandomGenerator() {
    assert_eq!(
        ::std::mem::size_of::<seal_UniformRandomGenerator>(),
        8usize,
        concat!("Size of: ", stringify!(seal_UniformRandomGenerator))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_UniformRandomGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_UniformRandomGenerator))
    );
}
impl Default for seal_UniformRandomGenerator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    ///Destroys the random number generator.
    #[link_name = "\u{1}_ZN4seal22UniformRandomGeneratorD1Ev"]
    pub fn seal_UniformRandomGenerator_UniformRandomGenerator_destructor(
        this: *mut seal_UniformRandomGenerator,
    );
}
#[repr(C)]
pub struct seal_UniformRandomGeneratorFactory__bindgen_vtable(::std::os::raw::c_void);
///Provides the base-class for a factory instance that creates instances of
///UniformRandomGenerator. This class is meant for users to sub-class to implement
///their own random number generators. Note that each instance returned may be
///used concurrently across separate threads, but each individual instance does
///not need to be thread-safe.
///
///@see UniformRandomGenerator for details relating to the random number generator
///instances.
///@see StandardRandomAdapterFactory for an implementation of
///UniformRandomGeneratorFactory that supports the standard C++ library's
///random number generators.
#[repr(C)]
#[derive(Debug)]
pub struct seal_UniformRandomGeneratorFactory {
    pub vtable_: *const seal_UniformRandomGeneratorFactory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_UniformRandomGeneratorFactory() {
    assert_eq!(
        ::std::mem::size_of::<seal_UniformRandomGeneratorFactory>(),
        8usize,
        concat!("Size of: ", stringify!(seal_UniformRandomGeneratorFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_UniformRandomGeneratorFactory>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_UniformRandomGeneratorFactory)
        )
    );
}
extern "C" {
    ///Returns the default random number generator factory. This instance should
    ///not be destroyed.
    #[link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactory15default_factoryEv"]
    pub fn seal_UniformRandomGeneratorFactory_default_factory() -> [u64; 2usize];
}
impl Default for seal_UniformRandomGeneratorFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_UniformRandomGeneratorFactory {
    #[inline]
    pub unsafe fn default_factory() -> [u64; 2usize] {
        seal_UniformRandomGeneratorFactory_default_factory()
    }
}
extern "C" {
    ///Destroys the random number generator factory.
    #[link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactoryD1Ev"]
    pub fn seal_UniformRandomGeneratorFactory_UniformRandomGeneratorFactory_destructor(
        this: *mut seal_UniformRandomGeneratorFactory,
    );
}
///Provides an implementation of UniformRandomGenerator for using very fast
///AES-NI randomness with given 128-bit seed.
#[repr(C)]
pub struct seal_FastPRNG {
    pub _base: seal_UniformRandomGenerator,
    pub __bindgen_padding_0: u64,
    pub aes_enc_: seal_AESEncryptor,
    pub buffer_: [u8; 128usize],
    pub counter_: usize,
    pub buffer_head_: seal_FastPRNG_const_iterator,
}
pub const seal_FastPRNG_bytes_per_block_: usize = 16;
pub const seal_FastPRNG_buffer_block_size_: usize = 8;
pub const seal_FastPRNG_buffer_size_: usize = 128;
#[test]
fn bindgen_test_layout_seal_FastPRNG() {
    assert_eq!(
        ::std::mem::size_of::<seal_FastPRNG>(),
        336usize,
        concat!("Size of: ", stringify!(seal_FastPRNG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).aes_enc_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(aes_enc_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).buffer_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(buffer_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).counter_ as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(counter_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).buffer_head_ as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(buffer_head_)
        )
    );
}
extern "C" {
    ///Creates a new FastPRNGFactory instance that initializes every FastPRNG
    ///instance it creates with the given seed.
    #[link_name = "\u{1}_ZN4seal8FastPRNGC1Emm"]
    pub fn seal_FastPRNG_FastPRNG(this: *mut seal_FastPRNG, seed_lw: u64, seed_hw: u64);
}
impl Default for seal_FastPRNG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FastPRNG {
    #[inline]
    pub unsafe fn new(seed_lw: u64, seed_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FastPRNG_FastPRNG(&mut __bindgen_tmp, seed_lw, seed_hw);
        __bindgen_tmp
    }
}
extern "C" {
    ///Generates a new uniform unsigned 32-bit random number. Note that the
    ///implementation does not need to be thread-safe.
    #[link_name = "\u{1}_ZN4seal8FastPRNG8generateEv"]
    pub fn seal_FastPRNG_generate(this: *mut ::std::os::raw::c_void) -> u32;
}
extern "C" {
    ///Destroys the random number generator.
    #[link_name = "\u{1}_ZN4seal8FastPRNGD1Ev"]
    pub fn seal_FastPRNG_FastPRNG_destructor(this: *mut seal_FastPRNG);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_FastPRNGFactory {
    pub _base: seal_UniformRandomGeneratorFactory,
    pub seed_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_FastPRNGFactory() {
    assert_eq!(
        ::std::mem::size_of::<seal_FastPRNGFactory>(),
        24usize,
        concat!("Size of: ", stringify!(seal_FastPRNGFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_FastPRNGFactory>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_FastPRNGFactory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNGFactory>())).seed_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNGFactory),
            "::",
            stringify!(seed_)
        )
    );
}
extern "C" {
    ///Creates a new FastPRNGFactory instance that initializes every FastPRNG
    ///instance it creates with the given seed. A zero seed (default value)
    ///signals that each random number generator created by the factory should
    ///use a different random seed obtained from std::random_device.
    ///
    ///@param[in] seed_lw Low-word for seed for the PRNG
    ///@param[in] seed_hw High-word for seed for the PRNG
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactoryC1Emm"]
    pub fn seal_FastPRNGFactory_FastPRNGFactory(
        this: *mut seal_FastPRNGFactory,
        seed_lw: u64,
        seed_hw: u64,
    );
}
impl Default for seal_FastPRNGFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FastPRNGFactory {
    #[inline]
    pub unsafe fn new(seed_lw: u64, seed_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FastPRNGFactory_FastPRNGFactory(&mut __bindgen_tmp, seed_lw, seed_hw);
        __bindgen_tmp
    }
}
extern "C" {
    ///Creates a new uniform random number generator. The caller of create needs
    ///to ensure the returned instance is destroyed once it is no longer in-use
    ///to prevent a memory leak.
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactory6createEv"]
    pub fn seal_FastPRNGFactory_create(this: *mut ::std::os::raw::c_void) -> [u64; 2usize];
}
extern "C" {
    ///Destroys the random number generator factory.
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactoryD1Ev"]
    pub fn seal_FastPRNGFactory_FastPRNGFactory_destructor(this: *mut seal_FastPRNGFactory);
}
///Provides an implementation of UniformRandomGenerator for the standard C++
///library's uniform random number generators.
///
///@tparam RNG specifies the type of the standard C++ library's random number
///generator (e.g., std::default_random_engine)
#[repr(C)]
#[derive(Debug)]
pub struct seal_StandardRandomAdapter<RNG> {
    pub _base: seal_UniformRandomGenerator,
    pub generator_: RNG,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RNG>>,
}
impl<RNG> Default for seal_StandardRandomAdapter<RNG> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///Provides an implementation of UniformRandomGeneratorFactory for the standard
///C++ library's random number generators.
///
///@tparam RNG specifies the type of the standard C++ library's random number
///generator (e.g., std::default_random_engine)
#[repr(C)]
#[derive(Debug)]
pub struct seal_StandardRandomAdapterFactory {
    pub _base: seal_UniformRandomGeneratorFactory,
}
impl Default for seal_StandardRandomAdapterFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_MemoryPoolHandle {
    pub pool_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_MemoryPoolHandle() {
    assert_eq!(
        ::std::mem::size_of::<seal_MemoryPoolHandle>(),
        16usize,
        concat!("Size of: ", stringify!(seal_MemoryPoolHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MemoryPoolHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MemoryPoolHandle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MemoryPoolHandle>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MemoryPoolHandle),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle6GlobalEv"]
    pub fn seal_MemoryPoolHandle_Global() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle11ThreadLocalEv"]
    pub fn seal_MemoryPoolHandle_ThreadLocal() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle3NewEb"]
    pub fn seal_MemoryPoolHandle_New(clear_on_destruction: bool) -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal16MemoryPoolHandle10pool_countEv"]
    pub fn seal_MemoryPoolHandle_pool_count(this: *const seal_MemoryPoolHandle) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal16MemoryPoolHandle16alloc_byte_countEv"]
    pub fn seal_MemoryPoolHandle_alloc_byte_count(this: *const seal_MemoryPoolHandle) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1Ev"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle(this: *mut seal_MemoryPoolHandle);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1ESt10shared_ptrINS_4util10MemoryPoolEE"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle1(
        this: *mut seal_MemoryPoolHandle,
        pool: [u64; 2usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1ERKS0_"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle2(
        this: *mut seal_MemoryPoolHandle,
        copy: *const seal_MemoryPoolHandle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1EOS0_"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle3(
        this: *mut seal_MemoryPoolHandle,
        source: *mut seal_MemoryPoolHandle,
    );
}
impl seal_MemoryPoolHandle {
    #[inline]
    pub unsafe fn Global() -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_Global()
    }
    #[inline]
    pub unsafe fn ThreadLocal() -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_ThreadLocal()
    }
    #[inline]
    pub unsafe fn New(clear_on_destruction: bool) -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_New(clear_on_destruction)
    }
    #[inline]
    pub unsafe fn pool_count(&self) -> usize {
        seal_MemoryPoolHandle_pool_count(self)
    }
    #[inline]
    pub unsafe fn alloc_byte_count(&self) -> usize {
        seal_MemoryPoolHandle_alloc_byte_count(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(pool: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle1(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(copy: *const seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle2(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(source: *mut seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle3(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
pub type seal_mm_prof_opt_t = u64;
pub const seal_mm_prof_opt_DEFAULT: seal_mm_prof_opt = 0;
pub const seal_mm_prof_opt_FORCE_GLOBAL: seal_mm_prof_opt = 1;
pub const seal_mm_prof_opt_FORCE_NEW: seal_mm_prof_opt = 2;
pub const seal_mm_prof_opt_FORCE_THREAD_LOCAL: seal_mm_prof_opt = 4;
pub type seal_mm_prof_opt = u64;
#[repr(C)]
pub struct seal_MMProf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProf {
    pub vtable_: *const seal_MMProf__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_MMProf() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProf>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProf))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProf>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProf))
    );
}
extern "C" {
    ///Creates a new MMProf.
    #[link_name = "\u{1}_ZN4seal6MMProfC2Ev"]
    pub fn seal_MMProf_MMProf(this: *mut seal_MMProf);
}
impl Default for seal_MMProf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProf {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProf_MMProf(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProf.
    #[link_name = "\u{1}_ZN4seal6MMProfD1Ev"]
    pub fn seal_MMProf_MMProf_destructor(this: *mut seal_MMProf);
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the global memory pool. SEAL uses this memory manager profile by default.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfGlobal {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfGlobal() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfGlobal>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfGlobal))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfGlobal>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfGlobal))
    );
}
extern "C" {
    ///Creates a new MMProfGlobal.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobalC1Ev"]
    pub fn seal_MMProfGlobal_MMProfGlobal(this: *mut seal_MMProfGlobal);
}
impl Default for seal_MMProfGlobal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfGlobal {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGlobal_MMProfGlobal(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfGlobal.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobalD1Ev"]
    pub fn seal_MMProfGlobal_MMProfGlobal_destructor(this: *mut seal_MMProfGlobal);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the global memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobal8get_poolEm"]
    pub fn seal_MMProfGlobal_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the new thread-safe memory pool. This profile should not be used except in
///special circumstances, as it does not result in any reuse of allocated memory.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfNew {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfNew() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfNew>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfNew))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfNew>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfNew))
    );
}
extern "C" {
    ///Creates a new MMProfNew.
    #[link_name = "\u{1}_ZN4seal9MMProfNewC1Ev"]
    pub fn seal_MMProfNew_MMProfNew(this: *mut seal_MMProfNew);
}
impl Default for seal_MMProfNew {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfNew {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfNew_MMProfNew(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfNew.
    #[link_name = "\u{1}_ZN4seal9MMProfNewD1Ev"]
    pub fn seal_MMProfNew_MMProfNew_destructor(this: *mut seal_MMProfNew);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to a new thread-safe memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal9MMProfNew8get_poolEm"]
    pub fn seal_MMProfNew_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///specific memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfFixed {
    pub _base: seal_MMProf,
    pub pool_: seal_MemoryPoolHandle,
}
#[test]
fn bindgen_test_layout_seal_MMProfFixed() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfFixed>(),
        24usize,
        concat!("Size of: ", stringify!(seal_MMProfFixed))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfFixed>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfFixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MMProfFixed>())).pool_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfFixed),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    ///Creates a new MMProfFixed. The MemoryPoolHandle given as argument is returned
    ///by every call to get_pool(mm_prof_opt_t).
    ///
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11MMProfFixedC1ENS_16MemoryPoolHandleE"]
    pub fn seal_MMProfFixed_MMProfFixed(this: *mut seal_MMProfFixed, pool: seal_MemoryPoolHandle);
}
impl Default for seal_MMProfFixed {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfFixed {
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfFixed_MMProfFixed(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfFixed.
    #[link_name = "\u{1}_ZN4seal11MMProfFixedD1Ev"]
    pub fn seal_MMProfFixed_MMProfFixed_destructor(this: *mut seal_MMProfFixed);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the stored memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal11MMProfFixed8get_poolEm"]
    pub fn seal_MMProfFixed_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the thread-local memory pool. This profile should be used with care, as any
///memory allocated by it will be released once the thread exits. In other words,
///the thread-local memory pool cannot be used to share memory across different
///threads. On the other hand, this profile can be useful when a very high number
///of threads doing simultaneous allocations would cause contention in the
///global memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfThreadLocal {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfThreadLocal() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfThreadLocal>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfThreadLocal))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfThreadLocal>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfThreadLocal))
    );
}
extern "C" {
    ///Creates a new MMProfThreadLocal.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocalC1Ev"]
    pub fn seal_MMProfThreadLocal_MMProfThreadLocal(this: *mut seal_MMProfThreadLocal);
}
impl Default for seal_MMProfThreadLocal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfThreadLocal {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfThreadLocal_MMProfThreadLocal(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfThreadLocal.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocalD1Ev"]
    pub fn seal_MMProfThreadLocal_MMProfThreadLocal_destructor(this: *mut seal_MMProfThreadLocal);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the thread-local memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocal8get_poolEm"]
    pub fn seal_MMProfThreadLocal_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///The MemoryManager class can be used to create instances of MemoryPoolHandle
///based on a given "profile". A profile is implemented by inheriting from the
///MMProf class (pure virtual) and encapsulates internal logic for deciding which
///memory pool to use.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_MemoryManager {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager8mm_prof_E"]
    pub static mut seal_MemoryManager_mm_prof_: u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager13switch_mutex_E"]
    pub static mut seal_MemoryManager_switch_mutex_: std_mutex;
}
#[test]
fn bindgen_test_layout_seal_MemoryManager() {
    assert_eq!(
        ::std::mem::size_of::<seal_MemoryManager>(),
        1usize,
        concat!("Size of: ", stringify!(seal_MemoryManager))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MemoryManager>(),
        1usize,
        concat!("Alignment of ", stringify!(seal_MemoryManager))
    );
}
extern "C" {
    ///Sets the current profile to a given one and returns a unique_ptr pointing
    ///to the previously set profile.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::invalid_argument if mm_prof is nullptr
    #[link_name = "\u{1}_ZN4seal13MemoryManager13SwitchProfileEOPNS_6MMProfE"]
    pub fn seal_MemoryManager_SwitchProfile(mm_prof: *mut *mut seal_MMProf) -> u64;
}
extern "C" {
    ///Sets the current profile to a given one and returns a unique_ptr pointing
    ///to the previously set profile.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::invalid_argument if mm_prof is nullptr
    #[link_name = "\u{1}_ZN4seal13MemoryManager13SwitchProfileEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MemoryManager_SwitchProfile1(mm_prof: *mut u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager7GetPoolEv"]
    pub fn seal_MemoryManager_GetPool() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManagerC1Ev"]
    pub fn seal_MemoryManager_MemoryManager(this: *mut seal_MemoryManager);
}
impl seal_MemoryManager {
    #[inline]
    pub unsafe fn SwitchProfile(mm_prof: *mut *mut seal_MMProf) -> u64 {
        seal_MemoryManager_SwitchProfile(mm_prof)
    }
    #[inline]
    pub unsafe fn SwitchProfile1(mm_prof: *mut u64) -> u64 {
        seal_MemoryManager_SwitchProfile1(mm_prof)
    }
    #[inline]
    pub unsafe fn GetPool() -> seal_MemoryPoolHandle {
        seal_MemoryManager_GetPool()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryManager_MemoryManager(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
///Class for a scoped switch of memory manager profile. This class acts as a scoped
///"guard" for changing the memory manager profile so that the programmer does
///not have to explicitly switch back afterwards and that other threads cannot
///change the MMProf. It can also help with exception safety by guaranteeing that
///the profile is switched back to the original if a function throws an exception
///after changing the profile for local use.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_MMProfGuard {
    pub old_prof_: u64,
    pub mm_switch_lock_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_MMProfGuard() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfGuard>(),
        24usize,
        concat!("Size of: ", stringify!(seal_MMProfGuard))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfGuard>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfGuard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MMProfGuard>())).old_prof_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfGuard),
            "::",
            stringify!(old_prof_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_MMProfGuard>())).mm_switch_lock_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfGuard),
            "::",
            stringify!(mm_switch_lock_)
        )
    );
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to currently stored memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be obtained
    ///on the first attempt, the function returns false; otherwise returns true.
    ///
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEv"]
    pub fn seal_MMProfGuard_try_lock(this: *mut seal_MMProfGuard) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to currently
    ///stored memory manager profile, stores the previously held profile, and
    ///keep the lock until unlocked or destroyed. The calling thread will block
    ///until the lock can be obtained.
    ///
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEv"]
    pub fn seal_MMProfGuard_lock(this: *mut seal_MMProfGuard);
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to the given memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be
    ///obtained on the first attempt, the function returns false; otherwise
    ///returns true.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MMProfGuard_try_lock1(this: *mut seal_MMProfGuard, mm_prof: *mut u64) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to the given
    ///memory manager profile, stores the previously held profile, and keep the
    ///lock until unlocked or destroyed. The calling thread will block until the
    ///lock can be obtained.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MMProfGuard_lock1(this: *mut seal_MMProfGuard, mm_prof: *mut u64);
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to the given memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be
    ///obtained on the first attempt, the function returns false; otherwise returns
    ///true.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEOPNS_6MMProfE"]
    pub fn seal_MMProfGuard_try_lock2(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut *mut seal_MMProf,
    ) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to the
    ///given memory manager profile, stores the previously held profile, and keep
    ///the lock until unlocked or destroyed. The calling thread will block until
    ///the lock can be obtained.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEOPNS_6MMProfE"]
    pub fn seal_MMProfGuard_lock2(this: *mut seal_MMProfGuard, mm_prof: *mut *mut seal_MMProf);
}
extern "C" {
    ///Releases the memory manager profile switch lock for MemoryManager, stores
    ///the current profile, and resets the profile to the one used before locking.
    ///
    ///@throw std::runtime_error if the lock is not owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard6unlockEv"]
    pub fn seal_MMProfGuard_unlock(this: *mut seal_MMProfGuard);
}
extern "C" {
    ///Returns whether the current MMProfGuard owns the memory manager profile
    ///switch lock.
    #[link_name = "\u{1}_ZN4seal11MMProfGuard9owns_lockEv"]
    pub fn seal_MMProfGuard_owns_lock(this: *mut seal_MMProfGuard) -> bool;
}
extern "C" {
    ///Creates a new MMProfGuard. If start_locked is true, this function will
    ///attempt to lock the MemoryManager for profile switch to mm_prof, perform
    ///the switch, and keep the lock until unlocked or destroyed. If start_lock
    ///is false, mm_prof will be stored but the switch will not be performed and
    ///a lock will not be obtained until lock() is explicitly called.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@param[in] start_locked Bool indicating whether the lock should be
    ///immediately obtained (true by default)
    #[link_name = "\u{1}_ZN4seal11MMProfGuardC1EOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EEb"]
    pub fn seal_MMProfGuard_MMProfGuard(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut u64,
        start_locked: bool,
    );
}
extern "C" {
    ///Creates a new MMProfGuard. If start_locked is true, this function will
    ///attempt to lock the MemoryManager for profile switch to mm_prof, perform
    ///the switch, and keep the lock until unlocked or destroyed. If start_lock
    ///is false, mm_prof will be stored but the switch will not be performed and
    ///a lock will not be obtained until lock() is explicitly called.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@param[in] start_locked Bool indicating whether the lock should be
    ///immediately obtained (true by default)
    #[link_name = "\u{1}_ZN4seal11MMProfGuardC1EOPNS_6MMProfEb"]
    pub fn seal_MMProfGuard_MMProfGuard1(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut *mut seal_MMProf,
        start_locked: bool,
    );
}
extern "C" {
    ///Destroys the MMProfGuard. If the memory manager profile switch lock is
    ///owned, releases the lock, and resets the profile to the one used before
    ///locking.
    #[link_name = "\u{1}_ZN4seal11MMProfGuardD1Ev"]
    pub fn seal_MMProfGuard_MMProfGuard_destructor(this: *mut seal_MMProfGuard);
}
impl seal_MMProfGuard {
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        seal_MMProfGuard_try_lock(self)
    }
    #[inline]
    pub unsafe fn lock(&mut self) {
        seal_MMProfGuard_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock1(&mut self, mm_prof: *mut u64) -> bool {
        seal_MMProfGuard_try_lock1(self, mm_prof)
    }
    #[inline]
    pub unsafe fn lock1(&mut self, mm_prof: *mut u64) {
        seal_MMProfGuard_lock1(self, mm_prof)
    }
    #[inline]
    pub unsafe fn try_lock2(&mut self, mm_prof: *mut *mut seal_MMProf) -> bool {
        seal_MMProfGuard_try_lock2(self, mm_prof)
    }
    #[inline]
    pub unsafe fn lock2(&mut self, mm_prof: *mut *mut seal_MMProf) {
        seal_MMProfGuard_lock2(self, mm_prof)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        seal_MMProfGuard_unlock(self)
    }
    #[inline]
    pub unsafe fn owns_lock(&mut self) -> bool {
        seal_MMProfGuard_owns_lock(self)
    }
    #[inline]
    pub unsafe fn new(mm_prof: *mut u64, start_locked: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGuard_MMProfGuard(&mut __bindgen_tmp, mm_prof, start_locked);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(mm_prof: *mut *mut seal_MMProf, start_locked: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGuard_MMProfGuard1(&mut __bindgen_tmp, mm_prof, start_locked);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        seal_MMProfGuard_MMProfGuard_destructor(self)
    }
}
pub const seal_scheme_type_BFV: seal_scheme_type = 1;
pub const seal_scheme_type_CKKS: seal_scheme_type = 2;
pub type seal_scheme_type = u8;
extern "C" {
    #[link_name = "\u{1}_ZN4seal15is_valid_schemeENS_11scheme_typeE"]
    pub fn seal_is_valid_scheme(scheme: seal_scheme_type) -> bool;
}
///The data type to store unique identifiers of encryption parameters.
pub type seal_parms_id_type = seal_util_HashFunction_sha3_block_type;
///Represents user-customizable encryption scheme settings. The parameters (most
///importantly poly_modulus, coeff_modulus, plain_modulus) significantly affect
///the performance, capabilities, and security of the encryption scheme. Once
///an instance of EncryptionParameters is populated with appropriate parameters,
///it can be used to create an instance of the SEALContext class, which verifies
///the validity of the parameters, and performs necessary pre-computations.
///
///Picking appropriate encryption parameters is essential to enable a particular
///application while balancing performance and security. Some encryption settings
///will not allow some inputs (e.g. attempting to encrypt a polynomial with more
///coefficients than poly_modulus or larger coefficients than plain_modulus) or,
///support the desired computations (with noise growing too fast due to too large
///plain_modulus and too small coeff_modulus).
///
///@par parms_id
///The EncryptionParameters class maintains at all times a 256-bit SHA-3 hash of
///the currently set encryption parameters. This hash acts as a unique identifier
///of the encryption parameters and is used by all further objects created for
///these encryption parameters. The parms_id is not intended to be directly modified
///by the user but is used internally for pre-computation data lookup and input
///validity checks. In modulus switching the user can use the parms_id to map the
///chain of encryption parameters.
///
///@par Thread Safety
///In general, reading from EncryptionParameters is thread-safe, while mutating
///is not.
///
///@warning Choosing inappropriate encryption parameters may lead to an encryption
///scheme that is not secure, does not perform well, and/or does not support the
///input and computation of the desired application. We highly recommend consulting
///an expert in RLWE-based encryption when selecting parameters, as this is where
///inexperienced users seem to most often make critical mistakes.
#[repr(C)]
#[derive(Debug)]
pub struct seal_EncryptionParameters {
    pub pool_: seal_MemoryPoolHandle,
    pub scheme_: seal_scheme_type,
    pub poly_modulus_degree_: usize,
    pub coeff_modulus_: [u64; 3usize],
    pub noise_standard_deviation_: f64,
    pub noise_max_deviation_: f64,
    pub random_generator_: [u64; 2usize],
    pub plain_modulus_: seal_util_global_variables_internal_mods_SmallModulus,
    pub parms_id_: seal_parms_id_type,
}
#[test]
fn bindgen_test_layout_seal_EncryptionParameters() {
    assert_eq!(
        ::std::mem::size_of::<seal_EncryptionParameters>(),
        168usize,
        concat!("Size of: ", stringify!(seal_EncryptionParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_EncryptionParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_EncryptionParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_EncryptionParameters>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).scheme_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(scheme_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).poly_modulus_degree_ as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(poly_modulus_degree_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).coeff_modulus_ as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(coeff_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).noise_standard_deviation_
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(noise_standard_deviation_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).noise_max_deviation_ as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(noise_max_deviation_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).random_generator_ as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(random_generator_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).plain_modulus_ as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(plain_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).parms_id_ as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(parms_id_)
        )
    );
}
extern "C" {
    ///Sets the degree of the polynomial modulus parameter to the specified value.
    ///The polynomial modulus directly affects the number of coefficients in
    ///plaintext polynomials, the size of ciphertext elements, the computational
    ///performance of the scheme (bigger is worse), and the security level (bigger
    ///is better). In SEAL the degree of the polynomial modulus must be a power
    ///of 2 (e.g.  1024, 2048, 4096, 8192, 16384, or 32768).
    ///
    ///@param[in] poly_modulus_degree The new polynomial modulus degree
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters23set_poly_modulus_degreeEm"]
    pub fn seal_EncryptionParameters_set_poly_modulus_degree(
        this: *mut seal_EncryptionParameters,
        poly_modulus_degree: usize,
    );
}
extern "C" {
    ///Sets the coefficient modulus parameter. The coefficient modulus consists
    ///of a list of distinct prime numbers, and is represented by a vector of
    ///SmallModulus objects. The coefficient modulus directly affects the size
    ///of ciphertext elements, the amount of computation that the scheme can perform
    ///(bigger is better), and the security level (bigger is worse). In SEAL each
    ///of the prime numbers in the coefficient modulus must be at most 60 bits,
    ///and must be congruent to 1 modulo 2*degree(poly_modulus).
    ///
    ///@param[in] coeff_modulus The new coefficient modulus
    ///@throws std::invalid_argument if size of coeff_modulus is invalid
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters17set_coeff_modulusERKSt6vectorINS_12SmallModulusESaIS2_EE"]
    pub fn seal_EncryptionParameters_set_coeff_modulus(
        this: *mut seal_EncryptionParameters,
        coeff_modulus: *const [u64; 3usize],
    );
}
extern "C" {
    ///Sets the plaintext modulus parameter. The plaintext modulus is an integer
    ///modulus represented by the SmallModulus class. The plaintext modulus
    ///determines the largest coefficient that plaintext polynomials can represent.
    ///It also affects the amount of computation that the scheme can perform
    ///(bigger is worse). In SEAL the plaintext modulus can be at most 60 bits
    ///long, but can otherwise be any integer. Note, however, that some features
    ///(e.g. batching) require the plaintext modulus to be of a particular form.
    ///
    ///@param[in] plain_modulus The new plaintext modulus
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters17set_plain_modulusERKNS_12SmallModulusE"]
    pub fn seal_EncryptionParameters_set_plain_modulus(
        this: *mut seal_EncryptionParameters,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    ///Sets the plaintext modulus parameter. The plaintext modulus is an integer
    ///modulus represented by the SmallModulus class. This constructor instead
    ///takes a std::uint64_t and automatically creates the SmallModulus object.
    ///The plaintext modulus determines the largest coefficient that plaintext
    ///polynomials can represent. It also affects the amount of computation that
    ///the scheme can perform (bigger is worse). In SEAL the plaintext modulus
    ///can be at most 60 bits long, but can otherwise be any integer. Note,
    ///however, that some features (e.g. batching) require the plaintext modulus
    ///to be of a particular form.
    ///
    ///@param[in] plain_modulus The new plaintext modulus
    ///@throws std::invalid_argument if plain_modulus is invalid
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters17set_plain_modulusEm"]
    pub fn seal_EncryptionParameters_set_plain_modulus1(
        this: *mut seal_EncryptionParameters,
        plain_modulus: u64,
    );
}
extern "C" {
    ///Sets the standard deviation of the noise distribution used for error
    ///sampling. This parameter directly affects the security level of the scheme.
    ///However, it should not be necessary for most users to change this parameter
    ///from its default value.
    ///
    ///@param[in] noise_standard_deviation The new standard deviation
    ///@throw std::invalid_argument if noise_standard_deviation is negative or
    ///too large
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters28set_noise_standard_deviationEd"]
    pub fn seal_EncryptionParameters_set_noise_standard_deviation(
        this: *mut seal_EncryptionParameters,
        noise_standard_deviation: f64,
    );
}
extern "C" {
    ///Sets the random number generator factory to use for encryption. By default,
    ///the random generator is set to UniformRandomGeneratorFactory::default_factory().
    ///Setting this value allows a user to specify a custom random number generator
    ///source.
    ///
    ///@param[in] random_generator Pointer to the random generator factory
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters20set_random_generatorESt10shared_ptrINS_29UniformRandomGeneratorFactoryEE"]
    pub fn seal_EncryptionParameters_set_random_generator(
        this: *mut seal_EncryptionParameters,
        random_generator: [u64; 2usize],
    );
}
extern "C" {
    ///Returns the encryption scheme type.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters6schemeEv"]
    pub fn seal_EncryptionParameters_scheme(
        this: *const seal_EncryptionParameters,
    ) -> seal_scheme_type;
}
extern "C" {
    ///Returns the degree of the polynomial modulus parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters19poly_modulus_degreeEv"]
    pub fn seal_EncryptionParameters_poly_modulus_degree(
        this: *const seal_EncryptionParameters,
    ) -> usize;
}
extern "C" {
    ///Returns a const reference to the currently set coefficient modulus parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters13coeff_modulusEv"]
    pub fn seal_EncryptionParameters_coeff_modulus(
        this: *const seal_EncryptionParameters,
    ) -> *const [u64; 3usize];
}
extern "C" {
    ///Returns a const reference to the currently set plaintext modulus parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters13plain_modulusEv"]
    pub fn seal_EncryptionParameters_plain_modulus(
        this: *const seal_EncryptionParameters,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the currently set standard deviation of the noise distribution.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters24noise_standard_deviationEv"]
    pub fn seal_EncryptionParameters_noise_standard_deviation(
        this: *const seal_EncryptionParameters,
    ) -> f64;
}
extern "C" {
    ///Returns the currently set maximum deviation of the noise distribution.
    ///This value cannot be directly controlled by the user, and is automatically
    ///set to be an appropriate multiple of the noise_standard_deviation parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters19noise_max_deviationEv"]
    pub fn seal_EncryptionParameters_noise_max_deviation(
        this: *const seal_EncryptionParameters,
    ) -> f64;
}
extern "C" {
    ///Returns a pointer to the random number generator factory to use for encryption.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters16random_generatorEv"]
    pub fn seal_EncryptionParameters_random_generator(
        this: *const seal_EncryptionParameters,
    ) -> [u64; 2usize];
}
extern "C" {
    ///Returns the parms_id of the current parameters. This function is intended
    ///mainly for internal use.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters8parms_idEv"]
    pub fn seal_EncryptionParameters_parms_id(
        this: *const seal_EncryptionParameters,
    ) -> *mut [u64; 4usize];
}
extern "C" {
    ///Saves EncryptionParameters to an output stream. The output is in binary
    ///format and is not human-readable. The output stream must have the "binary"
    ///flag set.
    ///
    ///@param[in] stream The stream to save the EncryptionParameters to
    ///@throws std::exception if the EncryptionParameters could not be written
    ///to stream
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters4SaveERKS0_RSo"]
    pub fn seal_EncryptionParameters_Save(
        parms: *const seal_EncryptionParameters,
        stream: *mut std_ostream,
    );
}
extern "C" {
    ///Loads EncryptionParameters from an input stream.
    ///
    ///@param[in] stream The stream to load the EncryptionParameters from
    ///@throws std::exception if valid EncryptionParameters could not be read
    ///from stream
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters4LoadERSi"]
    pub fn seal_EncryptionParameters_Load(stream: *mut std_istream) -> seal_EncryptionParameters;
}
extern "C" {
    ///Creates an empty set of encryption parameters. At a minimum, the user needs
    ///to specify the parameters poly_modulus, coeff_modulus, and plain_modulus
    ///for the parameters to be usable.
    ///
    ///@throw std::invalid_argument if scheme is not supported
    ///@see scheme_type for the supported schemes
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1ENS_11scheme_typeE"]
    pub fn seal_EncryptionParameters_EncryptionParameters(
        this: *mut seal_EncryptionParameters,
        scheme: seal_scheme_type,
    );
}
extern "C" {
    ///Creates a copy of a given instance of EncryptionParameters.
    ///
    ///@param[in] copy The EncryptionParameters to copy from
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1ERKS0_"]
    pub fn seal_EncryptionParameters_EncryptionParameters1(
        this: *mut seal_EncryptionParameters,
        copy: *const seal_EncryptionParameters,
    );
}
extern "C" {
    ///Creates a new EncryptionParameters instance by moving a given instance.
    ///
    ///@param[in] source The EncryptionParameters to move from
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1EOS0_"]
    pub fn seal_EncryptionParameters_EncryptionParameters2(
        this: *mut seal_EncryptionParameters,
        source: *mut seal_EncryptionParameters,
    );
}
impl Default for seal_EncryptionParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_EncryptionParameters {
    #[inline]
    pub unsafe fn set_poly_modulus_degree(&mut self, poly_modulus_degree: usize) {
        seal_EncryptionParameters_set_poly_modulus_degree(self, poly_modulus_degree)
    }
    #[inline]
    pub unsafe fn set_coeff_modulus(&mut self, coeff_modulus: *const [u64; 3usize]) {
        seal_EncryptionParameters_set_coeff_modulus(self, coeff_modulus)
    }
    #[inline]
    pub unsafe fn set_plain_modulus(
        &mut self,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) {
        seal_EncryptionParameters_set_plain_modulus(self, plain_modulus)
    }
    #[inline]
    pub unsafe fn set_plain_modulus1(&mut self, plain_modulus: u64) {
        seal_EncryptionParameters_set_plain_modulus1(self, plain_modulus)
    }
    #[inline]
    pub unsafe fn set_noise_standard_deviation(&mut self, noise_standard_deviation: f64) {
        seal_EncryptionParameters_set_noise_standard_deviation(self, noise_standard_deviation)
    }
    #[inline]
    pub unsafe fn set_random_generator(&mut self, random_generator: [u64; 2usize]) {
        seal_EncryptionParameters_set_random_generator(self, random_generator)
    }
    #[inline]
    pub unsafe fn scheme(&self) -> seal_scheme_type {
        seal_EncryptionParameters_scheme(self)
    }
    #[inline]
    pub unsafe fn poly_modulus_degree(&self) -> usize {
        seal_EncryptionParameters_poly_modulus_degree(self)
    }
    #[inline]
    pub unsafe fn coeff_modulus(&self) -> *const [u64; 3usize] {
        seal_EncryptionParameters_coeff_modulus(self)
    }
    #[inline]
    pub unsafe fn plain_modulus(
        &self,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus {
        seal_EncryptionParameters_plain_modulus(self)
    }
    #[inline]
    pub unsafe fn noise_standard_deviation(&self) -> f64 {
        seal_EncryptionParameters_noise_standard_deviation(self)
    }
    #[inline]
    pub unsafe fn noise_max_deviation(&self) -> f64 {
        seal_EncryptionParameters_noise_max_deviation(self)
    }
    #[inline]
    pub unsafe fn random_generator(&self) -> [u64; 2usize] {
        seal_EncryptionParameters_random_generator(self)
    }
    #[inline]
    pub unsafe fn parms_id(&self) -> *mut [u64; 4usize] {
        seal_EncryptionParameters_parms_id(self)
    }
    #[inline]
    pub unsafe fn Save(parms: *const seal_EncryptionParameters, stream: *mut std_ostream) {
        seal_EncryptionParameters_Save(parms, stream)
    }
    #[inline]
    pub unsafe fn Load(stream: *mut std_istream) -> seal_EncryptionParameters {
        seal_EncryptionParameters_Load(stream)
    }
    #[inline]
    pub unsafe fn new(scheme: seal_scheme_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters(&mut __bindgen_tmp, scheme);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_EncryptionParameters) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_EncryptionParameters) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_SEALContext {
    pub pool_: seal_MemoryPoolHandle,
    pub first_parms_id_: seal_parms_id_type,
    pub last_parms_id_: seal_parms_id_type,
}
#[test]
fn bindgen_test_layout_seal_SEALContext() {
    assert_eq!(
        ::std::mem::size_of::<seal_SEALContext>(),
        80usize,
        concat!("Size of: ", stringify!(seal_SEALContext))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_SEALContext>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_SEALContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_SEALContext>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext>())).first_parms_id_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(first_parms_id_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_SEALContext>())).last_parms_id_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(last_parms_id_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContext6CreateERKNS_20EncryptionParametersEb"]
    pub fn seal_SEALContext_Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal11SEALContext14first_parms_idEv"]
    pub fn seal_SEALContext_first_parms_id(this: *const seal_SEALContext) -> *mut [u64; 4usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal11SEALContext13last_parms_idEv"]
    pub fn seal_SEALContext_last_parms_id(this: *const seal_SEALContext) -> *mut [u64; 4usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContextC1Ev"]
    pub fn seal_SEALContext_SEALContext(this: *mut seal_SEALContext);
}
impl seal_SEALContext {
    #[inline]
    pub unsafe fn Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> [u64; 2usize] {
        seal_SEALContext_Create(parms, expand_mod_chain)
    }
    #[inline]
    pub unsafe fn first_parms_id(&self) -> *mut [u64; 4usize] {
        seal_SEALContext_first_parms_id(self)
    }
    #[inline]
    pub unsafe fn last_parms_id(&self) -> *mut [u64; 4usize] {
        seal_SEALContext_last_parms_id(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SEALContext_SEALContext(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_59 {
    pub _address: u8,
}
pub type seal_FastPRNG_const_iterator = *const value_type;
pub use self::seal_SEAL_BYTE as value_type;
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_unsigned_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
