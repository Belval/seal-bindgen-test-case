/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
pub type std_array__AT_Type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_mutex {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
pub type std_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_mutex>(),
        40usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex4lockEv"]
    pub fn std_mutex_lock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex8try_lockEv"]
    pub fn std_mutex_try_lock(this: *mut std_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex6unlockEv"]
    pub fn std_mutex_unlock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex13native_handleEv"]
    pub fn std_mutex_native_handle(this: *mut std_mutex) -> std_mutex_native_handle_type;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexC1Ev"]
    pub fn std_mutex_mutex(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexC1ERKS_"]
    pub fn std_mutex_mutex1(this: *mut std_mutex, arg1: *const std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexD1Ev"]
    pub fn std_mutex_mutex_destructor(this: *mut std_mutex);
}
impl std_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn native_handle(&mut self) -> std_mutex_native_handle_type {
        std_mutex_native_handle(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_mutex_mutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_mutex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_mutex_mutex1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_mutex_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unique_lock {
    pub _address: u8,
}
pub type std_unique_lock_mutex_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_mutex {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
pub type std_shared_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_shared_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_mutex>(),
        56usize,
        concat!("Size of: ", stringify!(std_shared_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_shared_mutex))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex4lockEv"]
    pub fn std_shared_mutex_lock(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex8try_lockEv"]
    pub fn std_shared_mutex_try_lock(this: *mut std_shared_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex6unlockEv"]
    pub fn std_shared_mutex_unlock(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex11lock_sharedEv"]
    pub fn std_shared_mutex_lock_shared(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex15try_lock_sharedEv"]
    pub fn std_shared_mutex_try_lock_shared(this: *mut std_shared_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex13unlock_sharedEv"]
    pub fn std_shared_mutex_unlock_shared(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex13native_handleEv"]
    pub fn std_shared_mutex_native_handle(
        this: *mut std_shared_mutex,
    ) -> std_shared_mutex_native_handle_type;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexC1Ev"]
    pub fn std_shared_mutex_shared_mutex(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexC1ERKS_"]
    pub fn std_shared_mutex_shared_mutex1(
        this: *mut std_shared_mutex,
        arg1: *const std_shared_mutex,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexD1Ev"]
    pub fn std_shared_mutex_shared_mutex_destructor(this: *mut std_shared_mutex);
}
impl std_shared_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_shared_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_shared_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_shared_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn lock_shared(&mut self) {
        std_shared_mutex_lock_shared(self)
    }
    #[inline]
    pub unsafe fn try_lock_shared(&mut self) -> bool {
        std_shared_mutex_try_lock_shared(self)
    }
    #[inline]
    pub unsafe fn unlock_shared(&mut self) {
        std_shared_mutex_unlock_shared(self)
    }
    #[inline]
    pub unsafe fn native_handle(&mut self) -> std_shared_mutex_native_handle_type {
        std_shared_mutex_native_handle(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_shared_mutex_shared_mutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_shared_mutex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_shared_mutex_shared_mutex1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_shared_mutex_shared_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_lock {
    pub _address: u8,
}
pub type std_shared_lock_mutex_type = u8;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type seal_SEAL_BYTE = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_SmallModulus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_is_uint64 {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12reverse_bitsEj"]
    pub fn seal_util_reverse_bits(operand: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12reverse_bitsEji"]
    pub fn seal_util_reverse_bits1(operand: u32, bit_count: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21get_msb_index_genericEPmm"]
    pub fn seal_util_get_msb_index_generic(result: *mut ::std::os::raw::c_ulong, value: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25get_significant_bit_countEm"]
    pub fn seal_util_get_significant_bit_count(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util11is_hex_charEc"]
    pub fn seal_util_is_hex_char(hex: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19nibble_to_upper_hexEi"]
    pub fn seal_util_nibble_to_upper_hex(nibble: ::std::os::raw::c_int) -> ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13hex_to_nibbleEc"]
    pub fn seal_util_hex_to_nibble(hex: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15get_uint64_byteEPmm"]
    pub fn seal_util_get_uint64_byte(value: *mut u64, byte_index: usize) -> *mut seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15get_uint64_byteEPKmm"]
    pub fn seal_util_get_uint64_byte1(
        value: *const u64,
        byte_index: usize,
    ) -> *const seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24get_hex_string_bit_countEPKci"]
    pub fn seal_util_get_hex_string_bit_count(
        hex_string: *const ::std::os::raw::c_char,
        char_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type seal_util_ReaderLock = [u64; 2usize];
pub type seal_util_WriterLock = [u64; 2usize];
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_util_ReaderWriterLocker {
    pub rw_lock_mutex_: std_shared_mutex,
}
#[test]
fn bindgen_test_layout_seal_util_ReaderWriterLocker() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ReaderWriterLocker>(),
        56usize,
        concat!("Size of: ", stringify!(seal_util_ReaderWriterLocker))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ReaderWriterLocker>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_ReaderWriterLocker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_ReaderWriterLocker>())).rw_lock_mutex_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_ReaderWriterLocker),
            "::",
            stringify!(rw_lock_mutex_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker12acquire_readEv"]
    pub fn seal_util_ReaderWriterLocker_acquire_read(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_ReaderLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker13acquire_writeEv"]
    pub fn seal_util_ReaderWriterLocker_acquire_write(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_WriterLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker16try_acquire_readEv"]
    pub fn seal_util_ReaderWriterLocker_try_acquire_read(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_ReaderLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker17try_acquire_writeEv"]
    pub fn seal_util_ReaderWriterLocker_try_acquire_write(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_WriterLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLockerC1Ev"]
    pub fn seal_util_ReaderWriterLocker_ReaderWriterLocker(this: *mut seal_util_ReaderWriterLocker);
}
impl seal_util_ReaderWriterLocker {
    #[inline]
    pub unsafe fn acquire_read(&mut self) -> seal_util_ReaderLock {
        seal_util_ReaderWriterLocker_acquire_read(self)
    }
    #[inline]
    pub unsafe fn acquire_write(&mut self) -> seal_util_WriterLock {
        seal_util_ReaderWriterLocker_acquire_write(self)
    }
    #[inline]
    pub unsafe fn try_acquire_read(&mut self) -> seal_util_ReaderLock {
        seal_util_ReaderWriterLocker_try_acquire_read(self)
    }
    #[inline]
    pub unsafe fn try_acquire_write(&mut self) -> seal_util_WriterLock {
        seal_util_ReaderWriterLocker_try_acquire_write(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_ReaderWriterLocker_ReaderWriterLocker(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_util_MemoryPoolItem {
    pub data_: *mut seal_SEAL_BYTE,
    pub next_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolItem() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolItem>(),
        16usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolItem))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolItem>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolItem>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolItem),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolItem>())).next_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolItem),
            "::",
            stringify!(next_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItem4dataEv"]
    pub fn seal_util_MemoryPoolItem_data(
        this: *mut seal_util_MemoryPoolItem,
    ) -> *mut seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14MemoryPoolItem4dataEv"]
    pub fn seal_util_MemoryPoolItem_data1(
        this: *const seal_util_MemoryPoolItem,
    ) -> *const seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItem4nextEv"]
    pub fn seal_util_MemoryPoolItem_next(
        this: *mut seal_util_MemoryPoolItem,
    ) -> *mut *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14MemoryPoolItem4nextEv"]
    pub fn seal_util_MemoryPoolItem_next1(
        this: *const seal_util_MemoryPoolItem,
    ) -> *const seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItemC1EPNS_9SEAL_BYTEE"]
    pub fn seal_util_MemoryPoolItem_MemoryPoolItem(
        this: *mut seal_util_MemoryPoolItem,
        data: *mut seal_SEAL_BYTE,
    );
}
impl Default for seal_util_MemoryPoolItem {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolItem {
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_SEAL_BYTE {
        seal_util_MemoryPoolItem_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *const seal_SEAL_BYTE {
        seal_util_MemoryPoolItem_data1(self)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> *mut *mut seal_util_MemoryPoolItem {
        seal_util_MemoryPoolItem_next(self)
    }
    #[inline]
    pub unsafe fn next1(&self) -> *const seal_util_MemoryPoolItem {
        seal_util_MemoryPoolItem_next1(self)
    }
    #[inline]
    pub unsafe fn new(data: *mut seal_SEAL_BYTE) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolItem_MemoryPoolItem(&mut __bindgen_tmp, data);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct seal_util_MemoryPoolHead__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHead {
    pub vtable_: *const seal_util_MemoryPoolHead__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_util_MemoryPoolHead_allocation {
    pub size: usize,
    pub data_ptr: *mut seal_SEAL_BYTE,
    pub free: usize,
    pub head_ptr: *mut seal_SEAL_BYTE,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHead_allocation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHead_allocation>(),
        32usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHead_allocation))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHead_allocation>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_util_MemoryPoolHead_allocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).data_ptr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(data_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).free as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).head_ptr as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(head_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolHead10allocationC1Ev"]
    pub fn seal_util_MemoryPoolHead_allocation_allocation(
        this: *mut seal_util_MemoryPoolHead_allocation,
    );
}
impl Default for seal_util_MemoryPoolHead_allocation {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHead_allocation {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHead_allocation_allocation(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHead() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHead>(),
        8usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHead))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHead>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHead))
    );
}
impl Default for seal_util_MemoryPoolHead {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolHeadD1Ev"]
    pub fn seal_util_MemoryPoolHead_MemoryPoolHead_destructor(this: *mut seal_util_MemoryPoolHead);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHeadMT {
    pub _base: seal_util_MemoryPoolHead,
    pub clear_on_destruction_: bool,
    pub locked_: u8,
    pub item_byte_count_: usize,
    pub item_count_: usize,
    pub allocs_: [u64; 3usize],
    pub first_item_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHeadMT() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHeadMT>(),
        64usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHeadMT))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHeadMT>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHeadMT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).locked_ as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(locked_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).item_byte_count_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(item_byte_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).item_count_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(item_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).allocs_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(allocs_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).first_item_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(first_item_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMTC1Emb"]
    pub fn seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT(
        this: *mut seal_util_MemoryPoolHeadMT,
        item_byte_count: usize,
        clear_on_destruction: bool,
    );
}
impl Default for seal_util_MemoryPoolHeadMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHeadMT {
    #[inline]
    pub unsafe fn new(item_byte_count: usize, clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT(
            &mut __bindgen_tmp,
            item_byte_count,
            clear_on_destruction,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMTD1Ev"]
    pub fn seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT_destructor(
        this: *mut seal_util_MemoryPoolHeadMT,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadMT15item_byte_countEv"]
    pub fn seal_util_MemoryPoolHeadMT_item_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadMT10item_countEv"]
    pub fn seal_util_MemoryPoolHeadMT_item_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMT3getEv"]
    pub fn seal_util_MemoryPoolHeadMT_get(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMT3addEPNS0_14MemoryPoolItemE"]
    pub fn seal_util_MemoryPoolHeadMT_add(
        this: *mut ::std::os::raw::c_void,
        new_first: *mut seal_util_MemoryPoolItem,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHeadST {
    pub _base: seal_util_MemoryPoolHead,
    pub clear_on_destruction_: bool,
    pub item_byte_count_: usize,
    pub item_count_: usize,
    pub allocs_: [u64; 3usize],
    pub first_item_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHeadST() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHeadST>(),
        64usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHeadST))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHeadST>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHeadST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).item_byte_count_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(item_byte_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).item_count_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(item_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).allocs_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(allocs_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).first_item_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(first_item_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadSTC1Emb"]
    pub fn seal_util_MemoryPoolHeadST_MemoryPoolHeadST(
        this: *mut seal_util_MemoryPoolHeadST,
        item_byte_count: usize,
        clear_on_destruction: bool,
    );
}
impl Default for seal_util_MemoryPoolHeadST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHeadST {
    #[inline]
    pub unsafe fn new(item_byte_count: usize, clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHeadST_MemoryPoolHeadST(
            &mut __bindgen_tmp,
            item_byte_count,
            clear_on_destruction,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadSTD1Ev"]
    pub fn seal_util_MemoryPoolHeadST_MemoryPoolHeadST_destructor(
        this: *mut seal_util_MemoryPoolHeadST,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadST15item_byte_countEv"]
    pub fn seal_util_MemoryPoolHeadST_item_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadST10item_countEv"]
    pub fn seal_util_MemoryPoolHeadST_item_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadST3getEv"]
    pub fn seal_util_MemoryPoolHeadST_get(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadST3addEPNS0_14MemoryPoolItemE"]
    pub fn seal_util_MemoryPoolHeadST_add(
        this: *mut ::std::os::raw::c_void,
        new_first: *mut seal_util_MemoryPoolItem,
    );
}
#[repr(C)]
pub struct seal_util_MemoryPool__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPool {
    pub vtable_: *const seal_util_MemoryPool__bindgen_vtable,
}
pub const seal_util_MemoryPool_alloc_size_multiplier: f64 = 1.05;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool27max_single_alloc_byte_countE"]
    pub static mut seal_util_MemoryPool_max_single_alloc_byte_count: usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool19max_pool_head_countE"]
    pub static mut seal_util_MemoryPool_max_pool_head_count: usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool26max_batch_alloc_byte_countE"]
    pub static mut seal_util_MemoryPool_max_batch_alloc_byte_count: usize;
}
pub const seal_util_MemoryPool_first_alloc_count: usize = 1;
#[test]
fn bindgen_test_layout_seal_util_MemoryPool() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPool>(),
        8usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPool))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPool>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPool))
    );
}
impl Default for seal_util_MemoryPool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPoolD1Ev"]
    pub fn seal_util_MemoryPool_MemoryPool_destructor(this: *mut seal_util_MemoryPool);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolMT {
    pub _base: seal_util_MemoryPool,
    pub clear_on_destruction_: bool,
    pub pools_locker_: seal_util_ReaderWriterLocker,
    pub pools_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolMT() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolMT>(),
        96usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolMT))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolMT>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolMT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).pools_locker_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(pools_locker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).pools_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(pools_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTC1Eb"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT(
        this: *mut seal_util_MemoryPoolMT,
        clear_on_destruction: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTC1ERKS1_"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT1(
        this: *mut seal_util_MemoryPoolMT,
        copy: *const seal_util_MemoryPoolMT,
    );
}
impl Default for seal_util_MemoryPoolMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolMT {
    #[inline]
    pub unsafe fn new(clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolMT_MemoryPoolMT(&mut __bindgen_tmp, clear_on_destruction);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_MemoryPoolMT) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolMT_MemoryPoolMT1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTD1Ev"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT_destructor(this: *mut seal_util_MemoryPoolMT);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMT18get_for_byte_countEm"]
    pub fn seal_util_MemoryPoolMT_get_for_byte_count(
        this: *mut ::std::os::raw::c_void,
        byte_count: usize,
    ) -> seal_util_Pointer<seal_SEAL_BYTE>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolMT10pool_countEv"]
    pub fn seal_util_MemoryPoolMT_pool_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolMT16alloc_byte_countEv"]
    pub fn seal_util_MemoryPoolMT_alloc_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolST {
    pub _base: seal_util_MemoryPool,
    pub clear_on_destruction_: bool,
    pub pools_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolST() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolST>(),
        40usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolST))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolST>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolST>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolST),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolST>())).pools_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolST),
            "::",
            stringify!(pools_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTC1Eb"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST(
        this: *mut seal_util_MemoryPoolST,
        clear_on_destruction: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTC1ERKS1_"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST1(
        this: *mut seal_util_MemoryPoolST,
        copy: *const seal_util_MemoryPoolST,
    );
}
impl Default for seal_util_MemoryPoolST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolST {
    #[inline]
    pub unsafe fn new(clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolST_MemoryPoolST(&mut __bindgen_tmp, clear_on_destruction);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_MemoryPoolST) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolST_MemoryPoolST1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTD1Ev"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST_destructor(this: *mut seal_util_MemoryPoolST);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolST18get_for_byte_countEm"]
    pub fn seal_util_MemoryPoolST_get_for_byte_count(
        this: *mut ::std::os::raw::c_void,
        byte_count: usize,
    ) -> seal_util_Pointer<seal_SEAL_BYTE>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolST10pool_countEv"]
    pub fn seal_util_MemoryPoolST_pool_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolST16alloc_byte_countEv"]
    pub fn seal_util_MemoryPoolST_alloc_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_Pointer<T> {
    pub data_: *mut T,
    pub head_: *mut seal_util_MemoryPoolHead,
    pub item_: *mut seal_util_MemoryPoolItem,
    pub alias_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for seal_util_Pointer<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_seal_SEAL_BYTE_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_ConstPointer<T> {
    pub data_: *mut T,
    pub head_: *mut seal_util_MemoryPoolHead,
    pub item_: *mut seal_util_MemoryPoolItem,
    pub alias_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for seal_util_ConstPointer<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_seal_SEAL_BYTE_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union seal_aes_block {
    pub u32: [u32; 4usize],
    pub u64: [u64; 2usize],
    pub i128: __m128i,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_seal_aes_block() {
    assert_eq!(
        ::std::mem::size_of::<seal_aes_block>(),
        16usize,
        concat!("Size of: ", stringify!(seal_aes_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).i128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(i128)
        )
    );
}
impl Default for seal_aes_block {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_AESEncryptor {
    pub round_key_: [__m128i; 11usize],
}
#[test]
fn bindgen_test_layout_seal_AESEncryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_AESEncryptor>(),
        176usize,
        concat!("Size of: ", stringify!(seal_AESEncryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_AESEncryptor>())).round_key_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_AESEncryptor),
            "::",
            stringify!(round_key_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptor7set_keyERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_set_key(this: *mut seal_AESEncryptor, key: *const seal_aes_block);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptERKNS_9aes_blockERS1_"]
    pub fn seal_AESEncryptor_ecb_encrypt(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_ecb_encrypt1(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
    ) -> seal_aes_block;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptEPKNS_9aes_blockEmPS1_"]
    pub fn seal_AESEncryptor_ecb_encrypt2(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor15counter_encryptEmmPNS_9aes_blockE"]
    pub fn seal_AESEncryptor_counter_encrypt(
        this: *const seal_AESEncryptor,
        start_index: usize,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1Ev"]
    pub fn seal_AESEncryptor_AESEncryptor(this: *mut seal_AESEncryptor);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1ERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_AESEncryptor1(
        this: *mut seal_AESEncryptor,
        key: *const seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1Emm"]
    pub fn seal_AESEncryptor_AESEncryptor2(this: *mut seal_AESEncryptor, key_lw: u64, key_hw: u64);
}
impl seal_AESEncryptor {
    #[inline]
    pub unsafe fn set_key(&mut self, key: *const seal_aes_block) {
        seal_AESEncryptor_set_key(self, key)
    }
    #[inline]
    pub unsafe fn ecb_encrypt(
        &self,
        plaintext: *const seal_aes_block,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_ecb_encrypt(self, plaintext, ciphertext)
    }
    #[inline]
    pub unsafe fn ecb_encrypt1(&self, plaintext: *const seal_aes_block) -> seal_aes_block {
        seal_AESEncryptor_ecb_encrypt1(self, plaintext)
    }
    #[inline]
    pub unsafe fn ecb_encrypt2(
        &self,
        plaintext: *const seal_aes_block,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_ecb_encrypt2(self, plaintext, aes_block_count, ciphertext)
    }
    #[inline]
    pub unsafe fn counter_encrypt(
        &self,
        start_index: usize,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_counter_encrypt(self, start_index, aes_block_count, ciphertext)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(key: *const seal_aes_block) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor1(&mut __bindgen_tmp, key);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(key_lw: u64, key_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor2(&mut __bindgen_tmp, key_lw, key_hw);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_AESDecryptor {
    pub round_key_: [__m128i; 11usize],
}
#[test]
fn bindgen_test_layout_seal_AESDecryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_AESDecryptor>(),
        176usize,
        concat!("Size of: ", stringify!(seal_AESDecryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_AESDecryptor>())).round_key_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_AESDecryptor),
            "::",
            stringify!(round_key_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor7set_keyERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_set_key(this: *mut seal_AESDecryptor, key: *const seal_aes_block);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor11ecb_decryptERKNS_9aes_blockERS1_"]
    pub fn seal_AESDecryptor_ecb_decrypt(
        this: *mut seal_AESDecryptor,
        ciphertext: *const seal_aes_block,
        plaintext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor11ecb_decryptERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_ecb_decrypt1(
        this: *mut seal_AESDecryptor,
        ciphertext: *const seal_aes_block,
    ) -> seal_aes_block;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptorC1Ev"]
    pub fn seal_AESDecryptor_AESDecryptor(this: *mut seal_AESDecryptor);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptorC1ERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_AESDecryptor1(
        this: *mut seal_AESDecryptor,
        key: *const seal_aes_block,
    );
}
impl seal_AESDecryptor {
    #[inline]
    pub unsafe fn set_key(&mut self, key: *const seal_aes_block) {
        seal_AESDecryptor_set_key(self, key)
    }
    #[inline]
    pub unsafe fn ecb_decrypt(
        &mut self,
        ciphertext: *const seal_aes_block,
        plaintext: *mut seal_aes_block,
    ) {
        seal_AESDecryptor_ecb_decrypt(self, ciphertext, plaintext)
    }
    #[inline]
    pub unsafe fn ecb_decrypt1(&mut self, ciphertext: *const seal_aes_block) -> seal_aes_block {
        seal_AESDecryptor_ecb_decrypt1(self, ciphertext)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESDecryptor_AESDecryptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(key: *const seal_aes_block) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESDecryptor_AESDecryptor1(&mut __bindgen_tmp, key);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct seal_UniformRandomGenerator__bindgen_vtable(::std::os::raw::c_void);
///Provides the base-class for a uniform random number generator. Instances of
///this class are typically returned from the UniformRandomGeneratorFactory class.
///This class is meant for users to sub-class to implement their own random number
///generators. The implementation should provide a uniform random unsigned 32-bit
///value for each call to generate(). Note that the library will never make
///concurrent calls to generate() to the same instance (but individual instances
///of the same class may have concurrent calls). The uniformity and unpredictability
///of the numbers generated is essential for making a secure cryptographic system.
///
///@see UniformRandomGeneratorFactory for the base-class of a factory class that
///generates UniformRandomGenerator instances.
///@see StandardRandomAdapter for an implementation of UniformRandomGenerator to
///support the C++ standard library's random number generators.
#[repr(C)]
#[derive(Debug)]
pub struct seal_UniformRandomGenerator {
    pub vtable_: *const seal_UniformRandomGenerator__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_UniformRandomGenerator() {
    assert_eq!(
        ::std::mem::size_of::<seal_UniformRandomGenerator>(),
        8usize,
        concat!("Size of: ", stringify!(seal_UniformRandomGenerator))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_UniformRandomGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_UniformRandomGenerator))
    );
}
impl Default for seal_UniformRandomGenerator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    ///Destroys the random number generator.
    #[link_name = "\u{1}_ZN4seal22UniformRandomGeneratorD1Ev"]
    pub fn seal_UniformRandomGenerator_UniformRandomGenerator_destructor(
        this: *mut seal_UniformRandomGenerator,
    );
}
#[repr(C)]
pub struct seal_UniformRandomGeneratorFactory__bindgen_vtable(::std::os::raw::c_void);
///Provides the base-class for a factory instance that creates instances of
///UniformRandomGenerator. This class is meant for users to sub-class to implement
///their own random number generators. Note that each instance returned may be
///used concurrently across separate threads, but each individual instance does
///not need to be thread-safe.
///
///@see UniformRandomGenerator for details relating to the random number generator
///instances.
///@see StandardRandomAdapterFactory for an implementation of
///UniformRandomGeneratorFactory that supports the standard C++ library's
///random number generators.
#[repr(C)]
#[derive(Debug)]
pub struct seal_UniformRandomGeneratorFactory {
    pub vtable_: *const seal_UniformRandomGeneratorFactory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_UniformRandomGeneratorFactory() {
    assert_eq!(
        ::std::mem::size_of::<seal_UniformRandomGeneratorFactory>(),
        8usize,
        concat!("Size of: ", stringify!(seal_UniformRandomGeneratorFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_UniformRandomGeneratorFactory>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_UniformRandomGeneratorFactory)
        )
    );
}
extern "C" {
    ///Returns the default random number generator factory. This instance should
    ///not be destroyed.
    #[link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactory15default_factoryEv"]
    pub fn seal_UniformRandomGeneratorFactory_default_factory() -> [u64; 2usize];
}
impl Default for seal_UniformRandomGeneratorFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_UniformRandomGeneratorFactory {
    #[inline]
    pub unsafe fn default_factory() -> [u64; 2usize] {
        seal_UniformRandomGeneratorFactory_default_factory()
    }
}
extern "C" {
    ///Destroys the random number generator factory.
    #[link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactoryD1Ev"]
    pub fn seal_UniformRandomGeneratorFactory_UniformRandomGeneratorFactory_destructor(
        this: *mut seal_UniformRandomGeneratorFactory,
    );
}
///Provides an implementation of UniformRandomGenerator for using very fast
///AES-NI randomness with given 128-bit seed.
#[repr(C)]
pub struct seal_FastPRNG {
    pub _base: seal_UniformRandomGenerator,
    pub __bindgen_padding_0: u64,
    pub aes_enc_: seal_AESEncryptor,
    pub buffer_: [u8; 128usize],
    pub counter_: usize,
    pub buffer_head_: seal_FastPRNG_const_iterator,
}
pub const seal_FastPRNG_bytes_per_block_: usize = 16;
pub const seal_FastPRNG_buffer_block_size_: usize = 8;
pub const seal_FastPRNG_buffer_size_: usize = 128;
#[test]
fn bindgen_test_layout_seal_FastPRNG() {
    assert_eq!(
        ::std::mem::size_of::<seal_FastPRNG>(),
        336usize,
        concat!("Size of: ", stringify!(seal_FastPRNG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).aes_enc_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(aes_enc_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).buffer_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(buffer_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).counter_ as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(counter_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).buffer_head_ as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(buffer_head_)
        )
    );
}
extern "C" {
    ///Creates a new FastPRNGFactory instance that initializes every FastPRNG
    ///instance it creates with the given seed.
    #[link_name = "\u{1}_ZN4seal8FastPRNGC1Emm"]
    pub fn seal_FastPRNG_FastPRNG(this: *mut seal_FastPRNG, seed_lw: u64, seed_hw: u64);
}
impl Default for seal_FastPRNG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FastPRNG {
    #[inline]
    pub unsafe fn new(seed_lw: u64, seed_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FastPRNG_FastPRNG(&mut __bindgen_tmp, seed_lw, seed_hw);
        __bindgen_tmp
    }
}
extern "C" {
    ///Generates a new uniform unsigned 32-bit random number. Note that the
    ///implementation does not need to be thread-safe.
    #[link_name = "\u{1}_ZN4seal8FastPRNG8generateEv"]
    pub fn seal_FastPRNG_generate(this: *mut ::std::os::raw::c_void) -> u32;
}
extern "C" {
    ///Destroys the random number generator.
    #[link_name = "\u{1}_ZN4seal8FastPRNGD1Ev"]
    pub fn seal_FastPRNG_FastPRNG_destructor(this: *mut seal_FastPRNG);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_FastPRNGFactory {
    pub _base: seal_UniformRandomGeneratorFactory,
    pub seed_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_FastPRNGFactory() {
    assert_eq!(
        ::std::mem::size_of::<seal_FastPRNGFactory>(),
        24usize,
        concat!("Size of: ", stringify!(seal_FastPRNGFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_FastPRNGFactory>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_FastPRNGFactory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNGFactory>())).seed_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNGFactory),
            "::",
            stringify!(seed_)
        )
    );
}
extern "C" {
    ///Creates a new FastPRNGFactory instance that initializes every FastPRNG
    ///instance it creates with the given seed. A zero seed (default value)
    ///signals that each random number generator created by the factory should
    ///use a different random seed obtained from std::random_device.
    ///
    ///@param[in] seed_lw Low-word for seed for the PRNG
    ///@param[in] seed_hw High-word for seed for the PRNG
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactoryC1Emm"]
    pub fn seal_FastPRNGFactory_FastPRNGFactory(
        this: *mut seal_FastPRNGFactory,
        seed_lw: u64,
        seed_hw: u64,
    );
}
impl Default for seal_FastPRNGFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FastPRNGFactory {
    #[inline]
    pub unsafe fn new(seed_lw: u64, seed_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FastPRNGFactory_FastPRNGFactory(&mut __bindgen_tmp, seed_lw, seed_hw);
        __bindgen_tmp
    }
}
extern "C" {
    ///Creates a new uniform random number generator. The caller of create needs
    ///to ensure the returned instance is destroyed once it is no longer in-use
    ///to prevent a memory leak.
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactory6createEv"]
    pub fn seal_FastPRNGFactory_create(this: *mut ::std::os::raw::c_void) -> [u64; 2usize];
}
extern "C" {
    ///Destroys the random number generator factory.
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactoryD1Ev"]
    pub fn seal_FastPRNGFactory_FastPRNGFactory_destructor(this: *mut seal_FastPRNGFactory);
}
///Provides an implementation of UniformRandomGenerator for the standard C++
///library's uniform random number generators.
///
///@tparam RNG specifies the type of the standard C++ library's random number
///generator (e.g., std::default_random_engine)
#[repr(C)]
#[derive(Debug)]
pub struct seal_StandardRandomAdapter<RNG> {
    pub _base: seal_UniformRandomGenerator,
    pub generator_: RNG,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RNG>>,
}
impl<RNG> Default for seal_StandardRandomAdapter<RNG> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///Provides an implementation of UniformRandomGeneratorFactory for the standard
///C++ library's random number generators.
///
///@tparam RNG specifies the type of the standard C++ library's random number
///generator (e.g., std::default_random_engine)
#[repr(C)]
#[derive(Debug)]
pub struct seal_StandardRandomAdapterFactory {
    pub _base: seal_UniformRandomGeneratorFactory,
}
impl Default for seal_StandardRandomAdapterFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_MemoryPoolHandle {
    pub pool_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_MemoryPoolHandle() {
    assert_eq!(
        ::std::mem::size_of::<seal_MemoryPoolHandle>(),
        16usize,
        concat!("Size of: ", stringify!(seal_MemoryPoolHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MemoryPoolHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MemoryPoolHandle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MemoryPoolHandle>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MemoryPoolHandle),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle6GlobalEv"]
    pub fn seal_MemoryPoolHandle_Global() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle11ThreadLocalEv"]
    pub fn seal_MemoryPoolHandle_ThreadLocal() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle3NewEb"]
    pub fn seal_MemoryPoolHandle_New(clear_on_destruction: bool) -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal16MemoryPoolHandle10pool_countEv"]
    pub fn seal_MemoryPoolHandle_pool_count(this: *const seal_MemoryPoolHandle) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal16MemoryPoolHandle16alloc_byte_countEv"]
    pub fn seal_MemoryPoolHandle_alloc_byte_count(this: *const seal_MemoryPoolHandle) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1Ev"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle(this: *mut seal_MemoryPoolHandle);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1ESt10shared_ptrINS_4util10MemoryPoolEE"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle1(
        this: *mut seal_MemoryPoolHandle,
        pool: [u64; 2usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1ERKS0_"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle2(
        this: *mut seal_MemoryPoolHandle,
        copy: *const seal_MemoryPoolHandle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1EOS0_"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle3(
        this: *mut seal_MemoryPoolHandle,
        source: *mut seal_MemoryPoolHandle,
    );
}
impl seal_MemoryPoolHandle {
    #[inline]
    pub unsafe fn Global() -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_Global()
    }
    #[inline]
    pub unsafe fn ThreadLocal() -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_ThreadLocal()
    }
    #[inline]
    pub unsafe fn New(clear_on_destruction: bool) -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_New(clear_on_destruction)
    }
    #[inline]
    pub unsafe fn pool_count(&self) -> usize {
        seal_MemoryPoolHandle_pool_count(self)
    }
    #[inline]
    pub unsafe fn alloc_byte_count(&self) -> usize {
        seal_MemoryPoolHandle_alloc_byte_count(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(pool: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle1(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(copy: *const seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle2(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(source: *mut seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle3(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
pub type seal_mm_prof_opt_t = u64;
pub const seal_mm_prof_opt_DEFAULT: seal_mm_prof_opt = 0;
pub const seal_mm_prof_opt_FORCE_GLOBAL: seal_mm_prof_opt = 1;
pub const seal_mm_prof_opt_FORCE_NEW: seal_mm_prof_opt = 2;
pub const seal_mm_prof_opt_FORCE_THREAD_LOCAL: seal_mm_prof_opt = 4;
pub type seal_mm_prof_opt = u64;
#[repr(C)]
pub struct seal_MMProf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProf {
    pub vtable_: *const seal_MMProf__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_MMProf() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProf>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProf))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProf>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProf))
    );
}
extern "C" {
    ///Creates a new MMProf.
    #[link_name = "\u{1}_ZN4seal6MMProfC2Ev"]
    pub fn seal_MMProf_MMProf(this: *mut seal_MMProf);
}
impl Default for seal_MMProf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProf {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProf_MMProf(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProf.
    #[link_name = "\u{1}_ZN4seal6MMProfD1Ev"]
    pub fn seal_MMProf_MMProf_destructor(this: *mut seal_MMProf);
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the global memory pool. SEAL uses this memory manager profile by default.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfGlobal {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfGlobal() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfGlobal>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfGlobal))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfGlobal>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfGlobal))
    );
}
extern "C" {
    ///Creates a new MMProfGlobal.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobalC1Ev"]
    pub fn seal_MMProfGlobal_MMProfGlobal(this: *mut seal_MMProfGlobal);
}
impl Default for seal_MMProfGlobal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfGlobal {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGlobal_MMProfGlobal(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfGlobal.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobalD1Ev"]
    pub fn seal_MMProfGlobal_MMProfGlobal_destructor(this: *mut seal_MMProfGlobal);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the global memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobal8get_poolEm"]
    pub fn seal_MMProfGlobal_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the new thread-safe memory pool. This profile should not be used except in
///special circumstances, as it does not result in any reuse of allocated memory.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfNew {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfNew() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfNew>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfNew))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfNew>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfNew))
    );
}
extern "C" {
    ///Creates a new MMProfNew.
    #[link_name = "\u{1}_ZN4seal9MMProfNewC1Ev"]
    pub fn seal_MMProfNew_MMProfNew(this: *mut seal_MMProfNew);
}
impl Default for seal_MMProfNew {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfNew {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfNew_MMProfNew(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfNew.
    #[link_name = "\u{1}_ZN4seal9MMProfNewD1Ev"]
    pub fn seal_MMProfNew_MMProfNew_destructor(this: *mut seal_MMProfNew);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to a new thread-safe memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal9MMProfNew8get_poolEm"]
    pub fn seal_MMProfNew_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///specific memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfFixed {
    pub _base: seal_MMProf,
    pub pool_: seal_MemoryPoolHandle,
}
#[test]
fn bindgen_test_layout_seal_MMProfFixed() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfFixed>(),
        24usize,
        concat!("Size of: ", stringify!(seal_MMProfFixed))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfFixed>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfFixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MMProfFixed>())).pool_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfFixed),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    ///Creates a new MMProfFixed. The MemoryPoolHandle given as argument is returned
    ///by every call to get_pool(mm_prof_opt_t).
    ///
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11MMProfFixedC1ENS_16MemoryPoolHandleE"]
    pub fn seal_MMProfFixed_MMProfFixed(this: *mut seal_MMProfFixed, pool: seal_MemoryPoolHandle);
}
impl Default for seal_MMProfFixed {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfFixed {
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfFixed_MMProfFixed(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfFixed.
    #[link_name = "\u{1}_ZN4seal11MMProfFixedD1Ev"]
    pub fn seal_MMProfFixed_MMProfFixed_destructor(this: *mut seal_MMProfFixed);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the stored memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal11MMProfFixed8get_poolEm"]
    pub fn seal_MMProfFixed_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the thread-local memory pool. This profile should be used with care, as any
///memory allocated by it will be released once the thread exits. In other words,
///the thread-local memory pool cannot be used to share memory across different
///threads. On the other hand, this profile can be useful when a very high number
///of threads doing simultaneous allocations would cause contention in the
///global memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfThreadLocal {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfThreadLocal() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfThreadLocal>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfThreadLocal))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfThreadLocal>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfThreadLocal))
    );
}
extern "C" {
    ///Creates a new MMProfThreadLocal.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocalC1Ev"]
    pub fn seal_MMProfThreadLocal_MMProfThreadLocal(this: *mut seal_MMProfThreadLocal);
}
impl Default for seal_MMProfThreadLocal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfThreadLocal {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfThreadLocal_MMProfThreadLocal(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfThreadLocal.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocalD1Ev"]
    pub fn seal_MMProfThreadLocal_MMProfThreadLocal_destructor(this: *mut seal_MMProfThreadLocal);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the thread-local memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocal8get_poolEm"]
    pub fn seal_MMProfThreadLocal_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///The MemoryManager class can be used to create instances of MemoryPoolHandle
///based on a given "profile". A profile is implemented by inheriting from the
///MMProf class (pure virtual) and encapsulates internal logic for deciding which
///memory pool to use.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_MemoryManager {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager8mm_prof_E"]
    pub static mut seal_MemoryManager_mm_prof_: u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager13switch_mutex_E"]
    pub static mut seal_MemoryManager_switch_mutex_: std_mutex;
}
#[test]
fn bindgen_test_layout_seal_MemoryManager() {
    assert_eq!(
        ::std::mem::size_of::<seal_MemoryManager>(),
        1usize,
        concat!("Size of: ", stringify!(seal_MemoryManager))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MemoryManager>(),
        1usize,
        concat!("Alignment of ", stringify!(seal_MemoryManager))
    );
}
extern "C" {
    ///Sets the current profile to a given one and returns a unique_ptr pointing
    ///to the previously set profile.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::invalid_argument if mm_prof is nullptr
    #[link_name = "\u{1}_ZN4seal13MemoryManager13SwitchProfileEOPNS_6MMProfE"]
    pub fn seal_MemoryManager_SwitchProfile(mm_prof: *mut *mut seal_MMProf) -> u64;
}
extern "C" {
    ///Sets the current profile to a given one and returns a unique_ptr pointing
    ///to the previously set profile.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::invalid_argument if mm_prof is nullptr
    #[link_name = "\u{1}_ZN4seal13MemoryManager13SwitchProfileEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MemoryManager_SwitchProfile1(mm_prof: *mut u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager7GetPoolEv"]
    pub fn seal_MemoryManager_GetPool() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManagerC1Ev"]
    pub fn seal_MemoryManager_MemoryManager(this: *mut seal_MemoryManager);
}
impl seal_MemoryManager {
    #[inline]
    pub unsafe fn SwitchProfile(mm_prof: *mut *mut seal_MMProf) -> u64 {
        seal_MemoryManager_SwitchProfile(mm_prof)
    }
    #[inline]
    pub unsafe fn SwitchProfile1(mm_prof: *mut u64) -> u64 {
        seal_MemoryManager_SwitchProfile1(mm_prof)
    }
    #[inline]
    pub unsafe fn GetPool() -> seal_MemoryPoolHandle {
        seal_MemoryManager_GetPool()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryManager_MemoryManager(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
///Class for a scoped switch of memory manager profile. This class acts as a scoped
///"guard" for changing the memory manager profile so that the programmer does
///not have to explicitly switch back afterwards and that other threads cannot
///change the MMProf. It can also help with exception safety by guaranteeing that
///the profile is switched back to the original if a function throws an exception
///after changing the profile for local use.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_MMProfGuard {
    pub old_prof_: u64,
    pub mm_switch_lock_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_MMProfGuard() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfGuard>(),
        24usize,
        concat!("Size of: ", stringify!(seal_MMProfGuard))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfGuard>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfGuard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MMProfGuard>())).old_prof_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfGuard),
            "::",
            stringify!(old_prof_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_MMProfGuard>())).mm_switch_lock_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfGuard),
            "::",
            stringify!(mm_switch_lock_)
        )
    );
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to currently stored memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be obtained
    ///on the first attempt, the function returns false; otherwise returns true.
    ///
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEv"]
    pub fn seal_MMProfGuard_try_lock(this: *mut seal_MMProfGuard) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to currently
    ///stored memory manager profile, stores the previously held profile, and
    ///keep the lock until unlocked or destroyed. The calling thread will block
    ///until the lock can be obtained.
    ///
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEv"]
    pub fn seal_MMProfGuard_lock(this: *mut seal_MMProfGuard);
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to the given memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be
    ///obtained on the first attempt, the function returns false; otherwise
    ///returns true.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MMProfGuard_try_lock1(this: *mut seal_MMProfGuard, mm_prof: *mut u64) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to the given
    ///memory manager profile, stores the previously held profile, and keep the
    ///lock until unlocked or destroyed. The calling thread will block until the
    ///lock can be obtained.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MMProfGuard_lock1(this: *mut seal_MMProfGuard, mm_prof: *mut u64);
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to the given memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be
    ///obtained on the first attempt, the function returns false; otherwise returns
    ///true.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEOPNS_6MMProfE"]
    pub fn seal_MMProfGuard_try_lock2(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut *mut seal_MMProf,
    ) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to the
    ///given memory manager profile, stores the previously held profile, and keep
    ///the lock until unlocked or destroyed. The calling thread will block until
    ///the lock can be obtained.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEOPNS_6MMProfE"]
    pub fn seal_MMProfGuard_lock2(this: *mut seal_MMProfGuard, mm_prof: *mut *mut seal_MMProf);
}
extern "C" {
    ///Releases the memory manager profile switch lock for MemoryManager, stores
    ///the current profile, and resets the profile to the one used before locking.
    ///
    ///@throw std::runtime_error if the lock is not owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard6unlockEv"]
    pub fn seal_MMProfGuard_unlock(this: *mut seal_MMProfGuard);
}
extern "C" {
    ///Returns whether the current MMProfGuard owns the memory manager profile
    ///switch lock.
    #[link_name = "\u{1}_ZN4seal11MMProfGuard9owns_lockEv"]
    pub fn seal_MMProfGuard_owns_lock(this: *mut seal_MMProfGuard) -> bool;
}
extern "C" {
    ///Creates a new MMProfGuard. If start_locked is true, this function will
    ///attempt to lock the MemoryManager for profile switch to mm_prof, perform
    ///the switch, and keep the lock until unlocked or destroyed. If start_lock
    ///is false, mm_prof will be stored but the switch will not be performed and
    ///a lock will not be obtained until lock() is explicitly called.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@param[in] start_locked Bool indicating whether the lock should be
    ///immediately obtained (true by default)
    #[link_name = "\u{1}_ZN4seal11MMProfGuardC1EOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EEb"]
    pub fn seal_MMProfGuard_MMProfGuard(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut u64,
        start_locked: bool,
    );
}
extern "C" {
    ///Creates a new MMProfGuard. If start_locked is true, this function will
    ///attempt to lock the MemoryManager for profile switch to mm_prof, perform
    ///the switch, and keep the lock until unlocked or destroyed. If start_lock
    ///is false, mm_prof will be stored but the switch will not be performed and
    ///a lock will not be obtained until lock() is explicitly called.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@param[in] start_locked Bool indicating whether the lock should be
    ///immediately obtained (true by default)
    #[link_name = "\u{1}_ZN4seal11MMProfGuardC1EOPNS_6MMProfEb"]
    pub fn seal_MMProfGuard_MMProfGuard1(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut *mut seal_MMProf,
        start_locked: bool,
    );
}
extern "C" {
    ///Destroys the MMProfGuard. If the memory manager profile switch lock is
    ///owned, releases the lock, and resets the profile to the one used before
    ///locking.
    #[link_name = "\u{1}_ZN4seal11MMProfGuardD1Ev"]
    pub fn seal_MMProfGuard_MMProfGuard_destructor(this: *mut seal_MMProfGuard);
}
impl seal_MMProfGuard {
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        seal_MMProfGuard_try_lock(self)
    }
    #[inline]
    pub unsafe fn lock(&mut self) {
        seal_MMProfGuard_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock1(&mut self, mm_prof: *mut u64) -> bool {
        seal_MMProfGuard_try_lock1(self, mm_prof)
    }
    #[inline]
    pub unsafe fn lock1(&mut self, mm_prof: *mut u64) {
        seal_MMProfGuard_lock1(self, mm_prof)
    }
    #[inline]
    pub unsafe fn try_lock2(&mut self, mm_prof: *mut *mut seal_MMProf) -> bool {
        seal_MMProfGuard_try_lock2(self, mm_prof)
    }
    #[inline]
    pub unsafe fn lock2(&mut self, mm_prof: *mut *mut seal_MMProf) {
        seal_MMProfGuard_lock2(self, mm_prof)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        seal_MMProfGuard_unlock(self)
    }
    #[inline]
    pub unsafe fn owns_lock(&mut self) -> bool {
        seal_MMProfGuard_owns_lock(self)
    }
    #[inline]
    pub unsafe fn new(mm_prof: *mut u64, start_locked: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGuard_MMProfGuard(&mut __bindgen_tmp, mm_prof, start_locked);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(mm_prof: *mut *mut seal_MMProf, start_locked: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGuard_MMProfGuard1(&mut __bindgen_tmp, mm_prof, start_locked);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        seal_MMProfGuard_MMProfGuard_destructor(self)
    }
}
pub const seal_scheme_type_BFV: seal_scheme_type = 1;
pub const seal_scheme_type_CKKS: seal_scheme_type = 2;
pub type seal_scheme_type = u8;
extern "C" {
    #[link_name = "\u{1}_ZN4seal15is_valid_schemeENS_11scheme_typeE"]
    pub fn seal_is_valid_scheme(scheme: seal_scheme_type) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_EncryptionParameters {
    pub pool_: seal_MemoryPoolHandle,
    pub scheme_: seal_scheme_type,
    pub random_generator_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_EncryptionParameters() {
    assert_eq!(
        ::std::mem::size_of::<seal_EncryptionParameters>(),
        40usize,
        concat!("Size of: ", stringify!(seal_EncryptionParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_EncryptionParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_EncryptionParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_EncryptionParameters>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).scheme_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(scheme_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).random_generator_ as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(random_generator_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters20set_random_generatorESt10shared_ptrINS_29UniformRandomGeneratorFactoryEE"]
    pub fn seal_EncryptionParameters_set_random_generator(
        this: *mut seal_EncryptionParameters,
        random_generator: [u64; 2usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters6schemeEv"]
    pub fn seal_EncryptionParameters_scheme(
        this: *const seal_EncryptionParameters,
    ) -> seal_scheme_type;
}
extern "C" {
    ///Returns a pointer to the random number generator factory to use for encryption.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters16random_generatorEv"]
    pub fn seal_EncryptionParameters_random_generator(
        this: *const seal_EncryptionParameters,
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1ENS_11scheme_typeE"]
    pub fn seal_EncryptionParameters_EncryptionParameters(
        this: *mut seal_EncryptionParameters,
        scheme: seal_scheme_type,
    );
}
impl Default for seal_EncryptionParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_EncryptionParameters {
    #[inline]
    pub unsafe fn set_random_generator(&mut self, random_generator: [u64; 2usize]) {
        seal_EncryptionParameters_set_random_generator(self, random_generator)
    }
    #[inline]
    pub unsafe fn scheme(&self) -> seal_scheme_type {
        seal_EncryptionParameters_scheme(self)
    }
    #[inline]
    pub unsafe fn random_generator(&self) -> [u64; 2usize] {
        seal_EncryptionParameters_random_generator(self)
    }
    #[inline]
    pub unsafe fn new(scheme: seal_scheme_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters(&mut __bindgen_tmp, scheme);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_SEALContext {
    pub pool_: seal_MemoryPoolHandle,
}
#[test]
fn bindgen_test_layout_seal_SEALContext() {
    assert_eq!(
        ::std::mem::size_of::<seal_SEALContext>(),
        16usize,
        concat!("Size of: ", stringify!(seal_SEALContext))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_SEALContext>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_SEALContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_SEALContext>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContext6CreateERKNS_20EncryptionParametersEb"]
    pub fn seal_SEALContext_Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContextC1Ev"]
    pub fn seal_SEALContext_SEALContext(this: *mut seal_SEALContext);
}
impl seal_SEALContext {
    #[inline]
    pub unsafe fn Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> [u64; 2usize] {
        seal_SEALContext_Create(parms, expand_mod_chain)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SEALContext_SEALContext(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_59 {
    pub _address: u8,
}
pub type seal_FastPRNG_const_iterator = *const value_type;
pub use self::seal_SEAL_BYTE as value_type;
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
